# A0124772E
###### ./main/java/logic/DecisionEngine.java
``` java
 */
public class DecisionEngine implements DecisionEngineSpec {

    // singleton instance, cosntructor and accessor
    private static DecisionEngine instance = new DecisionEngine();
    public static DecisionEngine getInstance() {
        if (instance == null) {
            instance = new DecisionEngine();
        }
        return instance;
    }
    private DecisionEngine() {
    }


    /**
     * the most important method in this class
     * this is the method that gets called by the Dispatcher
     * it takes in a command, executes it, and returns the execution result back to the caller
     * @param command
     * @return
     */
    @Override public ExecutionResult performCommand(Command command) {

        // this sort of nonsense should have been handled in the front end
        assert !command.hasInstruction(Command.Instruction.INVALID);
        assert !command.hasInstruction(Command.Instruction.UNRECOGNISED);

        // handle exit command here, without creating a task unnecessarily
        if (command.hasInstruction(Command.Instruction.EXIT)) {
            return ExecutionResult.shutdownSignal();
        }

        // Prepare final execution result to be returned
        ExecutionResult result = null;

        // all the standard commands
        switch (command.getInstruction()) {
            case ADD:
            case DELETE:
            case EDIT:
            case MARK:
                result = this.handleWriteOperation(command);
                break;
            case DISPLAY:
                result = this.handleDisplay(command);
                break;
            case SEARCH:
                result = this.handleSearch(command);
                break;
            case SCHEDULE:
                result = this.handleSchedule(command);
                break;
            case UNDO:
                boolean undoActuallyHappened = this.getWriteHistory().undo();
                result = this.displayAllTasks();
                if (!undoActuallyHappened) {
                    result.setErrorMessage(Message.UNDO_FAIL.toString());
                }
                break;
            case REDO:
                boolean redoActuallyHappened = this.getWriteHistory().redo();
                result = this.displayAllTasks();
                if (!redoActuallyHappened) {
                    result.setErrorMessage(Message.REDO_FAIL.toString());
                }
                break;
            default:
                // if we reach this point, LTA Command Parser has failed in his duty
                // and awaits court martial
                assert false;
        }

        return result;
    }


    @Override public void initialise() {
        StorageSpec<?> storage = this.getStorage();
        storage.initialise();
    }

    @Override public void shutdown() {
        StorageSpec<?> storage = this.getStorage();
        storage.shutdown();
    }


    ///////////////////////////////
    // START OF COMMAND HANDLERS //
    ///////////////////////////////

    /**
     * handles any one of ADD/DELETE/EDIT/MARK commands
     * essentially handles any commands that involve changing the state of one or more tasks in the Storage handler
     * another way to look at this method is that it handles any undo-able commands
     * @param command
     * @return
     */
    protected ExecutionResult handleWriteOperation(Command command) {
        assert command.hasInstruction(Command.Instruction.ADD)
                || command.hasInstruction(Command.Instruction.DELETE)
                || command.hasInstruction(Command.Instruction.EDIT)
                || command.hasInstruction(Command.Instruction.MARK);

        StorageWriteOperation op = new StorageWriteOperation(command, this.getStorage());
        String errorMsg = this.getWriteHistory().addToHistoryAfterExecuting(op);

        ExecutionResult result = this.displayAllTasks();
        result.setErrorMessage(errorMsg);

        return result;
    }

    /**
     * handles a DISPLAY command with bounds
     *
     * @param command
     * @return
     */
    protected ExecutionResult handleDisplay(Command command) {
        assert command.hasInstruction(Command.Instruction.DISPLAY);

        List<Task> listToDisplay = this.getStorage().getAll();

        // for each command parameter, filter the list of tasks
        if (command.hasParameter(Command.ParamName.TASK_NAME)) {
            String name = command.getParameter(Command.ParamName.TASK_NAME);
            listToDisplay = listToDisplay
                    .stream()
                    .filter(task -> task.getTaskName().equals(name))
                    .collect(Collectors.toList());
        }
        if (command.hasParameter(Command.ParamName.TASK_START)) {
            CustomTime from = command.getParameter(Command.ParamName.TASK_START);
            listToDisplay = listToDisplay
                    .stream()
                    .filter(task -> from.compareTo(task.getStartTime()) <= 0)
                    .collect(Collectors.toList());
        }
        if (command.hasParameter(Command.ParamName.TASK_END)) {
            CustomTime to = command.getParameter(Command.ParamName.TASK_END);
            listToDisplay = listToDisplay
                    .stream()
                    .filter(task -> to.compareTo(task.getEndTime()) >= 0)
                    .collect(Collectors.toList());
        }

        Collections.sort(listToDisplay, TaskPriorityComparator.getInstance());

        // at this point, we have a properly filtered list
        return new ExecutionResult(ViewType.TASK_LIST, listToDisplay);
    }


    /**
     * handles a SEARCH command, including PowerSearch functionality
     *
     * @param command
     * @return
     */
    protected ExecutionResult handleSearch(Command command) {
        assert command.hasInstruction(Command.Instruction.SEARCH);

        // PowerSearching!
        Pattern pattern = buildPowerSearchPattern(command);
        double averageQueryLength = getAverageQueryLength(command);

        List<Task> foundTask = this.getStorage().getAll().stream().map(item -> {
            // Match with task name first
            Matcher m = pattern.matcher(item.getTaskName());
            int matches = 0;
            List<Double> similarityIndex = new ArrayList<>();

            while (m.find()) {
                matches++;
                double similarity = averageQueryLength / m.group("MATCH").length();
                if (similarity > 1.0) {
                    similarity = 1.0;
                }
                similarityIndex.add(similarity);
            }

            double weightedMatch = matches * similarityIndex.stream()
                    .mapToDouble(Double::doubleValue).average().orElse(0.0);
            return new Pair<>(weightedMatch, item);
        }).filter(pair -> pair.getKey() > THRESHOLD_POWERSEARCH_WEIGHTED)
                .sorted((pair1, pair2) -> pair2.getKey().compareTo(pair1.getKey()))
                .map(Pair::getValue)
                .collect(Collectors.toList());

        return new ExecutionResult(ViewType.TASK_LIST, foundTask);
    }

    /**
     * handles the SCHEDULE command
     * @param command
     * @return
     */
    protected ExecutionResult handleSchedule(Command command) {
        assert command.hasInstruction(Command.Instruction.SCHEDULE);

        assert command.hasParameter(Command.ParamName.TASK_INDEX);
        Integer id = command.getParameter(Command.ParamName.TASK_INDEX);

        assert command.hasParameter(Command.ParamName.TASK_DURATION);
        Integer duration = command.getParameter(Command.ParamName.TASK_DURATION);
        assert duration != null;
        TemporalRange rangeToScheduleIn = this.getTaskScheduler().schedule(duration);

        // transform the SCHEDULE command into an EDIT command
        Command editCommand = new Command(Command.Instruction.EDIT);
        editCommand.setParameter(Command.ParamName.TASK_INDEX, id);
        editCommand.setParameter(Command.ParamName.TASK_START, rangeToScheduleIn.getStart());
        editCommand.setParameter(Command.ParamName.TASK_END, rangeToScheduleIn.getEnd());

        // just handle the newly generate EDIT command the usual way
        return this.handleWriteOperation(editCommand);
    }

    /////////////////////////////
    // END OF COMMAND HANDLERS //
    /////////////////////////////

    /**
     * a special display method that displays all tasks currently stored
     * @return
     */
    protected ExecutionResult displayAllTasks() {
        List<Task> listToDisplay = this.getStorage().getAll().stream()
                .sorted(TaskPriorityComparator.getInstance()).collect(Collectors.toList());

        return new ExecutionResult(ViewType.TASK_LIST, listToDisplay);
    }


    private SchedulerSpec getTaskScheduler() {
        return Scheduler.getInstance();
    }

    private StorageSpec<Task> getStorage() {
        return Storage.getInstance();
    }

    private WriteHistorySpec getWriteHistory() {
        return WriteHistory.getInstance();
    }


    // HELPER METHODS & FIELDS //

    private static final double THRESHOLD_POWERSEARCH_WEIGHTED = 0.0;

    private static Pattern buildPowerSearchPattern(Command command) {
        String query = command.getParameter(Command.ParamName.SEARCH_QUERY);
        // Split the query into words
        String[] words = query.split("\\s+");

        // Begin building pattern by signalling that we are looking for
        // a word that contains the characters
        StringBuilder patternBuilder = new StringBuilder();
        patternBuilder.append("\\b(?<MATCH>");

        // In that particular order. We achieve this by inserting
        // greedy word (\w*) pattern, slotted between the characters of
        // each of the query word
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            if (i != 0) {
                patternBuilder.append("|");
            }

            for (int j = 0; j < word.length(); j++) {
                patternBuilder.append("\\w*");
                patternBuilder.append(word.charAt(j));
            }
            patternBuilder.append("\\w*"); // At the end too
        }

        // Conclude the pattern
        patternBuilder.append(")\\b");
        return Pattern.compile(patternBuilder.toString(), Pattern.CASE_INSENSITIVE);
    }

    private static double getAverageQueryLength(Command command) {
        String query = command.getParameter(Command.ParamName.SEARCH_QUERY);
        return Arrays.asList(query.split("\\s+")).stream()
                .mapToDouble(String::length)
                .average().orElse(0.0);
    }
}
```
###### ./main/java/logic/Dispatcher.java
``` java
 */
public class Dispatcher implements DispatcherSpec {

    /**
     * Singleton instance
     */
    private static Dispatcher instance;

    /**
     * Properties
     */
    private final Function<Command, ExecutionResult> _commandExecutor;

    /**
     * TODO: Write JavaDoc
     */
    private Dispatcher() {
        this._commandExecutor = command -> {
            ExecutionResult result = getDecisionEngine().performCommand(command);
            assert result != null;

            // Handle shutdown
            if (result.isShutdownSignal()) {

                // Shutdown both engines
                this.shutdown();

                // Demand application to close
                ApplicationContext.mainContext().getPrimaryStage().close();

                return result;
            }

            // If not, gracefully falls through to displaying result
            getTranslationEngine().displayResult(result);
            return result;
        };
    }

    @Override
    public void shutdown() {
        this.getDecisionEngine().shutdown();
        this.getTranslationEngine().shutdown();
    }

    /**
     * TODO: Write JavaDoc
     *
     * @return
     */
    public static Dispatcher getInstance() {
        if (instance == null) {
            instance = new Dispatcher();
        }
        return instance;
    }

    @Override public void initialise() {
        // Initialize DecisionEngine and trigger its storage
        this.getDecisionEngine().initialise();

        // Initialize TranslationEngine and trigger its view
        this.getTranslationEngine().initialise();

        // Add command handler to translation engine
        this.getTranslationEngine().setCommandExecutionHandler(this._commandExecutor);
    }

    @Override public void start() {
        // Execute and display the result of the initial command
        this._commandExecutor.andThen(result -> {
            this.getTranslationEngine().displayResult(result);
            return null;
        }).apply(constructInitialCommand());
    }

    @Override public TranslationEngineSpec getTranslationEngine() {
        return TranslationEngine.getInstance();
    }

    @Override public DecisionEngineSpec getDecisionEngine() {
        return DecisionEngine.getInstance();
    }

    private static Command constructInitialCommand() {
        return Command.initialCommand();
    }

}
```
###### ./main/java/logic/Scheduler.java
``` java
 */
public class Scheduler implements SchedulerSpec {

    // singleton instance, constructor and accessor
    private static final Scheduler instance = new Scheduler(Storage.getInstance());
    public static Scheduler getInstance() {
        return instance;
    }
    protected Scheduler(Storage storage) {
        this._storage = storage;
    }

    // storage instance to be used by this scheduler
    private Storage _storage;


    /**
     * finds a time range in which to slot a task of specified duration in
     * @param durationInMinutes of task to slot in
     * @return time range to slot the task in
     */
    @Override
    public TemporalRange schedule(Integer durationInMinutes) {

        // get the task that ends the latest, if it exists
        Optional<CustomTime> endOfRangeToSearchIfItExists = this._storage.getAll()
                .stream()
                .filter(task -> task.getStartTime() != null && task.getEndTime() != null)
                .map(Task::getEndTime)
                .max(CustomTime::compareTo);

        // if such a task does not exist, then there are no tasks, so just schedule the new task immediately
        if (!endOfRangeToSearchIfItExists.isPresent()) {
            return new TemporalRange(CustomTime.now(), CustomTime.now().plusMinutes(durationInMinutes));
        }

        CustomTime startOfRangeToSearch = CustomTime.now();
        CustomTime endOfRangeToSearch = endOfRangeToSearchIfItExists.get();

        List<TemporalRange> freeSlots = this.getFreeSlots(startOfRangeToSearch, endOfRangeToSearch);

        List<TemporalRange> suitableFreeSlots = freeSlots
                .stream()
                .filter(range -> CustomTime.difference(range.getStart(), range.getEnd()) >= durationInMinutes)
                .map(range -> {
                    CustomTime startTime = range.getStart();
                    CustomTime endTime = new CustomTime(
                            LocalDateTime.of(startTime.getDate(), startTime.getTime())
                                    .plusMinutes(durationInMinutes));
                    return new TemporalRange(startTime, endTime);
                })
                .collect(Collectors.toList());

        // just choose the day after the end date if we can't find a suitable slot
        if (suitableFreeSlots.isEmpty()) {
            return new TemporalRange(endOfRangeToSearch.plusDays(1),
                    endOfRangeToSearch.plusDays(1).plusMinutes(durationInMinutes));
        } else {
            // get the first suitable free slot and return it
            return suitableFreeSlots.get(0);
        }
    }

    /**
     * checks task to be inserted for clashes (collisions) with pre-existing tasks
     * @param task to check for collision
     * @return does the task collide?
     */
    @Override
    public boolean isColliding(Task task) {
        TemporalRange taskRange = new TemporalRange(task.getStartTime(), task.getEndTime());

        if (taskRange.getStart() == null || taskRange.getEnd() == null) {
            return false;
        }

        return !this._storage.getAll()
                .stream()
                .map(task_ -> new TemporalRange(task_.getStartTime(), task_.getEndTime()))
                .filter(range -> range.getStart() != null && range.getEnd() != null) // ensure start and end time objects are there
                .filter(range_ -> taskRange.overlaps(range_))
                .collect(Collectors.toList())
                .isEmpty();
    }


    // HELPER METHODS //

    /**
     * gets free time slots within the specified bounds
     * the resulting list will be disjoint and sorted
     * @param lowerBound
     * @param upperBound
     * @return
     */
    protected List<TemporalRange> getFreeSlots(CustomTime lowerBound, CustomTime upperBound) {
        // if lowerBound >= upperBound, return an empty list for obvious reasons
        if (lowerBound.compareTo(upperBound) >= 0) {
            return new LinkedList<TemporalRange>();
        }

        // first get the disjoint list of occupied time slots, sorted in chronological order
        List<TemporalRange> occupiedRanges = this._storage.getAll()
                .stream()
                .map(task -> new TemporalRange(task.getStartTime(), task.getEndTime()))
                .collect(Collectors.toList());

        // remove tasks with missing start/end times
        occupiedRanges = this.collapseOverlappingRanges(occupiedRanges
                .stream()
                .filter(range -> range.getStart() != null && range.getEnd() != null)
                .collect(Collectors.toList()));

        // strip tasks that end before the lower bound or start after the upper bound
        occupiedRanges = occupiedRanges
                .stream()
                .filter(task -> !(lowerBound.compareTo(task.getEnd()) >= 0 || upperBound.compareTo(task.getStart()) <= 0))
                .collect(Collectors.toList());

        /*
         * run through the whole list of occupied ranges
         * iteratively build the free ranges starting from the lower bound
         * for each occupied range,
         *     its start ends the free range just prior to it
         *     its end starts the free range just after it
         */
        List<TemporalRange> freeSlots = new LinkedList<>();
        CustomTime currentFreeSlotStartTime = lowerBound;

        for (TemporalRange range : occupiedRanges) {
            TemporalRange freeRangeToAdd = new TemporalRange(currentFreeSlotStartTime, range.getStart());
            freeSlots.add(freeRangeToAdd);
            currentFreeSlotStartTime = range.getEnd(); // the next free range starts only after the current occupied range ends
        }
        freeSlots.add(new TemporalRange(currentFreeSlotStartTime, upperBound));

        // fix potential problems at the endpoints if there are occupied ranges that cross the lower or upper bounds
        freeSlots = freeSlots
                .stream()
                .filter(range -> range.getStart().compareTo(range.getEnd()) < 0)
                .collect(Collectors.toList());

        return freeSlots;
    }

    /**
     * takes a list of temporal ranges and returns a new list of disjoint ranges that represent
     * the time spanned by all the ranges
     * the list is first sorted by start time, which ultimately results in a list sorted in chronological order
     *
     * @param ranges the original ranges
     * @return new list of disjoint ranges sorted in chronological order
     */
    protected List<TemporalRange> collapseOverlappingRanges(List<TemporalRange> ranges) {
        List<TemporalRange> collapsedRanges = new LinkedList<>();
        List<TemporalRange> originalRanges = ranges
                .stream()
                .sorted((range1, range2) -> range1.getStart().compareTo(range2.getStart()))
                .collect(Collectors.toList());

        TemporalRange currentRange = TemporalRange.getUniversalRange();

        for (TemporalRange range : originalRanges) {
            if (range.overlaps(currentRange) || range.isAdjacentTo(currentRange)) {
                // the range accumulator can still be extended with this one
                currentRange = currentRange.merge(range);
            } else {
                // freeze the current accumulator and add it to the list of collapsed ranges, start a new range
                collapsedRanges.add(currentRange);
                currentRange = range;
            }
        }
        collapsedRanges.add(currentRange);

        return collapsedRanges;
    }

    /**
     * takes a disjoint, sorted time range of time slots and adds time slots blocking out the qiet period from 0000-0800
     * @param ranges disjoint and sorted
     * @return a disjoint and sorted range expanded to include the additional slots denoting the quiet period
     */
    protected List<TemporalRange> blockOutQuietTime(List<TemporalRange> ranges) {
        LocalDate minDate = ranges
                .stream()
                .map(TemporalRange::getStart)
                .min(CustomTime::compareTo)
                .get().getDate();
        LocalDate maxDate = ranges
                .stream()
                .map(TemporalRange::getEnd)
                .max(CustomTime::compareTo)
                .get().getDate();

        List<LocalDate> dateRange = new LinkedList<>();
        for (LocalDate i = minDate; i.isBefore(maxDate) || i.isEqual(maxDate); i = i.plusDays(1)) {
            dateRange.add(i);
        }

        List<TemporalRange> blockedQuietTimeRanges = dateRange
                .stream()
                .map(date -> {
                    CustomTime start = new CustomTime(date, LocalTime.of(0, 0));
                    CustomTime end = new CustomTime(date, LocalTime.of(8, 0));
                    return new TemporalRange(start, end);
                })
                .collect(Collectors.toList());

        blockedQuietTimeRanges.addAll(this.collapseOverlappingRanges(ranges));
        return this.collapseOverlappingRanges(blockedQuietTimeRanges);
    }
}
```
###### ./main/java/logic/StorageWriteOperation.java
``` java
 */
public class StorageWriteOperation {

    private static final String ERROR_RANGE_EMPTY_FOR_DELETE = Message.DELETE_FAIL.toString();
    private static final String ERROR_RANGE_EMPTY_FOR_MARK = Message.MARK_FAIL.toString();
    private static final String WARNING_COLLIDING_TASK = "Task collides with another already existing task!";

    private Function<?, String> _initialOperation; // returns the error string for the operation, to be placed in an ExecutionResult
    private Function<?, Boolean> _undoOperation; // returns false if nothing was done due to original operation not being run
    private Function<?, Boolean> _redoOperation; // returns false if nothing was done due to original operation not being run

    private Command _command; // command that gave rise to this execution unit
    private Integer _id = null; // id of the task handled by this op, if used
    private int[] _idRange = null; // set of ids handled by this op, if used
    private Task _taskPreModification = null; // snapshot of the task before it is modified
    private Task _taskPostModification = null; // snapshot of the task after it is modified
    private boolean _wasExecuted = false; // success code for the operation

    private StorageSpec<Task> _storage; // the Storage instance used for the operation

    public StorageWriteOperation(Command command, StorageSpec storage) {
        this._command = command;
        this._storage = storage;

        switch (this._command.getInstruction()) {
            case ADD:
                this.createAsAddUnit();
                break;
            case DELETE:
                this.createAsDeleteUnit();
                break;
            case EDIT:
                this.createAsEditUnit();
                break;
            case MARK:
                this.createAsMarkUnit();
                break;
            default:
                assert false;
        }
    }


    // getters
    public Function<?, String> getInitialOperation() {
        return this._initialOperation;
    }

    public Function<?, Boolean> getUndoOperation() {
        return this._undoOperation;
    }

    public Function<?, Boolean> getRedoOperation() {
        return this._redoOperation;
    }

    public boolean isOperationExecuted() {
        return this._wasExecuted;
    }


    private void createAsAddUnit() {

        this._initialOperation = v -> {
            // initialise temp vars to store the new task properties
            String name = null;
            CustomTime from = null;
            CustomTime to = null;

            /*
             * for each command parameter, check if it was supplied
             * if so, extract the value and set the appropriate reference above to point to the extracted value
             */

            // extract name if it exists
            if (this._command.hasParameter(Command.ParamName.TASK_NAME)) {
                name = this._command.getParameter(Command.ParamName.TASK_NAME);
            }
            // extract start time if it exists
            if (this._command.hasParameter(Command.ParamName.TASK_START)) {
                from = this._command.getParameter(Command.ParamName.TASK_START);

                // if the start time is not defined, default to 0000
                if (!from.hasTime()) {
                    from = new CustomTime(from.getDate(), LocalTime.of(7, 0));
                }
            }
            // extract end time if it exists
            if (this._command.hasParameter(Command.ParamName.TASK_END)) {
                to = this._command.getParameter(Command.ParamName.TASK_END);

                // if the end time is not defined, default to 2359
                if (!to.hasTime()) {
                    to = new CustomTime(to.getDate(), LocalTime.of(23, 00));
                }
            }

            // ensure the task has a name, at the very least
            assert name != null;

            // we now build the Task object for adding into the store
            Task taskToAdd = new Task(null, name, "", from, to);

            // extract priority if it exists
            if (this._command.hasParameter(Command.ParamName.PRIORITY_VALUE)) {
                Task.Priority priority = this._command.getParameter(Command.ParamName.PRIORITY_VALUE);
                if (priority != null) {
                    taskToAdd.setPriority(priority);
                }
            }

            // check for collisions
            boolean taskCollides = Scheduler.getInstance().isColliding(taskToAdd);

            this._id = this._storage.save(taskToAdd);

            this._wasExecuted = true; // adding a task never fails

            if (taskCollides) {
                System.err.println(WARNING_COLLIDING_TASK);
                return WARNING_COLLIDING_TASK;
            } else {
                return null;
            }
        };


        this._undoOperation = v -> {
            assert this._id != null;
            this._storage.remove(this._id);
            return true;
        };

        this._redoOperation = v -> {
            assert this._id != null;
            this._storage.undelete(this._id);
            return true;
        };

    }

    private void createAsDeleteUnit() {

        this._initialOperation = v -> {
            // get the set of IDs whose corresponding tasks are to be deleted
            if (this._command.hasTrueValue(Command.ParamName.TASK_UNIVERSALLY_QUANTIFIED)) {
                this._idRange = this._storage.getNonDeletedTasks()
                        .stream() // get all tasks (that have not been deleted)
                        .mapToInt(Integer::intValue).toArray();
            } else {
                List<Range> ranges = this._command.getParameter(Command.ParamName.TASK_INDEX_RANGES);
                this._idRange = Arrays.stream(Range.enumerateRanges(ranges))
                        .filter(id -> !this._storage.get(id).isDeleted())
                        .toArray();
            }

            assert this._idRange != null;

            if (this._idRange.length == 0) {
                this._wasExecuted = false; // we didn't delete anything
                return ERROR_RANGE_EMPTY_FOR_DELETE;
            }

            Arrays.stream(this._idRange)
                    .forEach(this._storage::remove);

            this._wasExecuted = true; // we actually deleted some tasks
            return null;
        };


        this._undoOperation = v -> {
            if (!this._wasExecuted) {
                return false;
            }

            assert this._idRange != null;
            Arrays.stream(this._idRange)
                    .forEach(this._storage::undelete);
            return true;
        };

        this._redoOperation = v -> {
            if (!this._wasExecuted) {
                return false;
            }

            assert this._idRange != null;
            Arrays.stream(this._idRange)
                    .forEach(this._storage::remove);
            return true;
        };

    }

    private void createAsEditUnit() {

        this._initialOperation = v -> {
            this._id = this._command.getParameter(Command.ParamName.TASK_INDEX);
            assert this._id != null;
            Task task = this._storage.get(this._id);

             this._taskPreModification = task.clone(); // take snapshot of task before modifying it, for undo operation

            // check which parameters have changed
            if (this._command.hasParameter(Command.ParamName.TASK_NAME)) {
                task.setTaskName(this._command.getParameter(Command.ParamName.TASK_NAME));
            }
            if (this._command.hasParameter(Command.ParamName.TASK_START)) {
                task.setStartTime(this._command.getParameter(Command.ParamName.TASK_START));
            }
            if (this._command.hasParameter(Command.ParamName.TASK_END)) {
                task.setEndTime(this._command.getParameter(Command.ParamName.TASK_END));
            }

            // Check for priority
            if (this._command.hasParameter(Command.ParamName.PRIORITY_VALUE)) {
                Task.Priority priority = this._command.getParameter(Command.ParamName.PRIORITY_VALUE);
                if (priority != null) {
                    task.setPriority(priority);
                }
            }

            this._taskPostModification = task.clone(); // take snapshot of task after modifying it, for redo operation

            this._wasExecuted = true; // editing a task never fails
            return null;
        };


        this._undoOperation = v -> {
            assert this._taskPreModification != null;
            this._storage.save(this._taskPreModification);
            return true;
        };

        this._redoOperation = v -> {
            assert this._taskPostModification != null;
            this._storage.save(this._taskPostModification);
            return true;
        };

    }

    private void createAsMarkUnit() {

        this._initialOperation = v -> {
            List<Range> ranges = this._command.getParameter(Command.ParamName.TASK_INDEX_RANGES);
            this._idRange = Arrays.stream(Range.enumerateRanges(ranges))
                    .filter(id -> {
                        Task task = this._storage.get(id);
                        return !(task.isDeleted() || task.isCompleted());
                    })
                    .toArray();

            assert this._idRange != null;

            if (this._idRange.length == 0) {
                this._wasExecuted = false;
                return ERROR_RANGE_EMPTY_FOR_MARK;
            }

            Arrays.stream(this._idRange)
                    .mapToObj(this._storage::get)
                    .forEach(task -> task.setCompleted(true));

            this._wasExecuted = true;
            return null;
        };


        this._undoOperation = v -> {
            if (!this._wasExecuted) {
                return false;
            }

            assert this._idRange != null;

            Arrays.stream(this._idRange)
                    .mapToObj(this._storage::get)
                    .forEach(task -> task.setCompleted(false));
            return true;
        };

        this._redoOperation = v -> {
            if (!this._wasExecuted) {
                return false;
            }

            assert this._idRange != null;

            Arrays.stream(this._idRange)
                    .mapToObj(this._storage::get)
                    .forEach(task -> task.setCompleted(true));
            return true;
        };

    }
}
```
###### ./main/java/logic/WriteHistory.java
``` java
 */
public class WriteHistory implements WriteHistorySpec {

    // singleton declaration
    private static WriteHistory instance = null;
    public static WriteHistory getInstance() {
        if (instance == null) {
            instance = new WriteHistory();
        }
        return instance;
    }
    private WriteHistory() {
    }


    // fields
    private LinkedList<StorageWriteOperation> _opSequence = new LinkedList<>();
    private int _opIndex = -1; // refers to latest operation performed (without being cancelled by an undo)


    // methods
    @Override
    public void addToHistory(StorageWriteOperation op) {
        this.checkIndexInvariant();

        this.chopOffAfterCurrentIndex();
        this._opSequence.add(op);
        this._opIndex++;

        this.checkIndexInvariant();
    }

    @Override
    public String addToHistoryAfterExecuting(StorageWriteOperation op) {
        String errorMsg = op.getInitialOperation().apply(null);
        this.addToHistory(op);
        return errorMsg;
    }


    /**
     * @return false if there were no ops to undo, true otherwise
     */
    @Override
    public boolean undo() {
        this.checkIndexInvariant();

        if (!this.existsOperationsToUndo()) {
            return false;
        }

        // get the operation we wish to undo
        StorageWriteOperation op = this._opSequence.get(this._opIndex--);

        // apply undo operation if the operation was actually performed, otherwise skip over it
        if (!op.isOperationExecuted()) {
            return this.undo();
        }

        boolean isUndoSuccessful = op.getUndoOperation().apply(null);
        assert isUndoSuccessful;

        this.checkIndexInvariant();

        return true;
    }

    /**
     * @return false if there were no ops to redo, true otherwise
     */
    @Override
    public boolean redo() {
        this.checkIndexInvariant();

        if (!this.existsOperationsToRedo()) {
            return false;
        }

        // get the operation we wish to redo
        StorageWriteOperation op = this._opSequence.get(++this._opIndex);

        // apply redo operation if the operation was actually performed, otherwise skip over it
        if (!op.isOperationExecuted()) {
            this.redo();
        }

        boolean isRedoSuccessful = op.getRedoOperation().apply(null);
        assert isRedoSuccessful;

        this.checkIndexInvariant();

        return true;
    }


    // helper methods
    private void chopOffAfter(int index) {
        this.checkIndexInvariant();
        this._opSequence.subList(index + 1, this._opSequence.size()).clear();
        this.checkIndexInvariant();
    }

    private void chopOffAfterCurrentIndex() {
        this.checkIndexInvariant();
        this.chopOffAfter(this._opIndex);
        this.checkIndexInvariant();
    }

    private boolean existsOperationsToUndo() {
        return this._opIndex >= 0;
    }

    private boolean existsOperationsToRedo() {
        return this._opIndex + 1 < this._opSequence.size();
    }

    // blows up if the index invariant is not satisfied;
    private void checkIndexInvariant() {
        boolean isLowerBoundInvariantSatisfied = this._opIndex >= -1;
        boolean isUpperBoundInvariantSatisfied = this._opIndex < this._opSequence.size();

        assert isLowerBoundInvariantSatisfied && isUpperBoundInvariantSatisfied;
    }
}
```
###### ./main/java/shared/TemporalRange.java
``` java
 */
public class TemporalRange {
    private CustomTime _start;
    private CustomTime _end;

    /**
     * standard constructor
     * @param start
     * @param end
     */
    public TemporalRange(CustomTime start, CustomTime end) {
        this.setStart(start);
        this.setEnd(end);
    }

    /**
     * special constructor used only to create the universal range
     */
    private TemporalRange() {
        this._start = null;
        this._end = null;
    }


    /**
     * a special temporal range that overlaps and is contained in every other temporal range
     * it is universally quantified over its start and end times, so those values are completely ignored
     * @return
     */
    public static TemporalRange getUniversalRange() {
        return new TemporalRange() {

            @Override
            public boolean overlaps(TemporalRange rangeToCheck) {
                return true;
            }

            @Override
            public boolean isAdjacentTo(TemporalRange rangeToCheck) {
                return false;
            }

            @Override
            public TemporalRange merge(TemporalRange rangeToMerge) {
                return rangeToMerge;
            }

            @Override
            public boolean isUniversal() {
                return true;
            }
        };
    }


    public boolean isUniversal() {
        return false;
    }


    public CustomTime getStart() {
        return this._start;
    }

    public CustomTime getEnd() {
        return this._end;
    }

    public void setStart(CustomTime start) {
        this._start = start;
    }

    public void setEnd(CustomTime end) {
        this._end = end;
    }


    public boolean overlaps(TemporalRange rangeToCheck) {
        if (rangeToCheck.equals(getUniversalRange())) {
            return true;
        }

        boolean endsBefore = this.getEnd().compareTo(rangeToCheck.getStart()) <= 0;
        boolean startsAfter = this.getStart().compareTo(rangeToCheck.getEnd()) >= 0;

        return !(endsBefore || startsAfter);
    }

    public boolean isAdjacentTo(TemporalRange rangeToCheck) {
        if (rangeToCheck.equals(getUniversalRange())) {
            return false;
        }

        boolean endsAtStart = this.getEnd().compareTo(rangeToCheck.getStart()) == 0;
        boolean startsAtEnd = this.getStart().compareTo(rangeToCheck.getEnd()) == 0;

        return endsAtStart || startsAtEnd;
    }

    public TemporalRange merge(TemporalRange rangeToMerge) {
        if (rangeToMerge.equals(getUniversalRange())) {
            return this;
        }

        CustomTime start;
        CustomTime end;

        if (!(this.overlaps(rangeToMerge) || this.isAdjacentTo(rangeToMerge))) {
            return null; // we cannot merge two completely separate ranges with no common points
        }

        if (this.getStart().compareTo(rangeToMerge.getStart()) < 0) {
            start = this.getStart();
        } else {
            start = rangeToMerge.getStart();
        }

        if (this.getEnd().compareTo(rangeToMerge.getEnd()) > 0) {
            end = this.getEnd();
        } else {
            end = rangeToMerge.getEnd();
        }

        return new TemporalRange(start, end);
    }


    /*
     * inherited methods from Object
     */

    @Override
    public boolean equals(Object o) {
        assert o instanceof TemporalRange;

        // handle the universal range, in which _start and _end are not defined
        if (this.isUniversal()) {
            return ((TemporalRange) o).isUniversal();
        }

        TemporalRange range = (TemporalRange) o;
        return this._start.equals(range._start) && this._end.equals(range._end);
    }
}
```
###### ./main/java/skeleton/CommandParserSpec.java
``` java
 */
public interface CommandParserSpec {

    void initialise();

    Command parse(String commandString);
}
```
###### ./main/java/skeleton/DecisionEngineSpec.java
``` java
 */
public interface DecisionEngineSpec {

    void initialise();

    ExecutionResult performCommand(Command cmd);

    void shutdown();

}
```
###### ./main/java/skeleton/DispatcherSpec.java
``` java
 */
public interface DispatcherSpec {

    TranslationEngineSpec getTranslationEngine();

    DecisionEngineSpec getDecisionEngine();

    void initialise();

    void start();

    void shutdown();
}
```
###### ./main/java/skeleton/SchedulerSpec.java
``` java
 */
public interface SchedulerSpec {

    public TemporalRange schedule(Integer durationInMinutes);

    public boolean isColliding(Task task);
}
```
###### ./main/java/skeleton/UserInterfaceSpec.java
``` java
 */
public interface UserInterfaceSpec {

    /**
     * This method is called when the GUI is first set up and the component is linked to the code.
     *
     * Should only be called once, when the UserInterface is first instantiated
     */
    void initialize();
    /**
     * this method set the behavior for the commandInput Box when receiving input from the user
     *
     * @param commandInputHandler the function that defines the actions taken after receiving input
     */
    void setOnCommandInputHandler(Function<String, Void> commandInputHandler);
    /**
     * This method is called when the GUI is going to be displayed. initialize() method should be called before hand
     *
     * Should only be called once, when the UserInterface is first instantiated
     */
    void show();

    /***
     * the render() method is called when you want to update the display in the main container.
     *
     * @param view View object which component is going to be displayed
     */
    void render(View view);

    /***
     * This method will update the notification message following the given input parameter, and play
     * the animation to bring the notification bar on-screen for a given duration.
     *
     * @param title message to be displayed in the notification bar
     */
    void showNotification(String title);

    /***
     *
     */
    void cleanUp();

    void setHeaderTitle(String title);
}
```
###### ./main/java/skeleton/WriteHistorySpec.java
``` java
 */
public interface WriteHistorySpec {

    public void addToHistory(StorageWriteOperation op);

    public String addToHistoryAfterExecuting(StorageWriteOperation op);

    public boolean undo(); // returns whether undo succeeded

    public boolean redo(); // returns whether redo succeeded

}
```
###### ./test/java/logic/DecisionEngineTest.java
``` java
 */
public class DecisionEngineTest {
    private DecisionEngine decisionEngine;

    private static final int specialTestID = -1;

    // times for test use
    private static final String testDate1String = "23032016 1600";
    private static final String testDate2String = "23032016 2100";
    private static final String testDate3String = "24032016 0800";
    private static final CustomTime testDate1 = new CustomTime(2016, Month.MARCH, 23, 16, 0);
    private static final CustomTime testDate2 = new CustomTime(2016, Month.MARCH, 23, 21, 0);
    private static final CustomTime testDate3 = new CustomTime(2016, Month.MARCH, 24, 8, 0);

    // task names for test use
    private static final String name1 = "magazine of 30 rounds, load";
    private static final String name2 = "100 metre snap target";

    /**
     * creates a Task from a specified command object when it makes sense we
     * should blow up when creating a Task doesn't really make sense
     *
     * @param cmd
     * @return
     */
    private static Task createTask(Command cmd) {
        // initialisation
        String name = null;
        CustomTime from = null;
        CustomTime to = null;

        // for each command parameter, check if it was supplied
        // if so, extract the value and set the appropriate reference above to
        // point to the extracted value
        if (cmd.hasParameter(Command.ParamName.TASK_NAME)) {
            name = cmd.getParameter(Command.ParamName.TASK_NAME);
        }
        if (cmd.hasParameter(Command.ParamName.TASK_START)) {
            from = cmd.getParameter(Command.ParamName.TASK_START);
        }
        if (cmd.hasParameter(Command.ParamName.TASK_END)) {
            to = cmd.getParameter(Command.ParamName.TASK_END);
        }

        // we now build the Task object for adding into the store
        return new Task(null, name, "", from, to);
    }


    @Before
    public void setUp() throws IOException {
        this.decisionEngine = DecisionEngine.getInstance();
    }

    @Test
    public void testCreateTask() {
        Command fullAdd = new Command(Command.Instruction.ADD);
        fullAdd.setParameter(Command.ParamName.TASK_NAME, name1);
        fullAdd.setParameter(Command.ParamName.TASK_START, testDate1);
        fullAdd.setParameter(Command.ParamName.TASK_END, testDate2);

        Command partialAdd = new Command(Command.Instruction.ADD);
        Task task1 = createTask(fullAdd);
        task1.setId(specialTestID);
        Task expected1 = new Task(specialTestID, name1, null, testDate1, testDate2);
        Task task2 = createTask(partialAdd);
        task2.setId(specialTestID);
        Task expected2 = new Task(specialTestID, name2, null, testDate2, testDate3);

        assertEquals(task1, expected1);
        assertEquals(task2, expected2);
    }

}
```
###### ./test/java/logic/SchedulerTest.java
``` java
 */
public class SchedulerTest {
    /**
     * class to enable dependency injection of Storage
```
###### ./test/java/logic/SchedulerTest.java
``` java
     */
    static class StorageTester extends Storage {
        public StorageTester() {
            super();
        }
    }


    public static final CustomTime time1 = new CustomTime(2016, Month.APRIL, 1, 8, 0);
    public static final CustomTime time2 = new CustomTime(2016, Month.APRIL, 2, 16, 0);
    public static final CustomTime time3 = new CustomTime(2016, Month.APRIL, 3, 12, 0);
    public static final CustomTime time4 = new CustomTime(2016, Month.APRIL, 4, 7, 30);
    public static final CustomTime time5 = new CustomTime(2016, Month.APRIL, 11, 10, 0);
    public static final CustomTime time6 = new CustomTime(2016, Month.APRIL, 12, 6, 0);
    public static final CustomTime time7 = new CustomTime(2016, Month.MAY, 1, 18, 0);
    public static final CustomTime time8 = new CustomTime(2016, Month.MAY, 1, 7, 0);
    public static final CustomTime time9 = new CustomTime(2016, Month.MAY, 1, 10, 0);
    public static final CustomTime timeA = new CustomTime(2016, Month.APRIL, 12, 6, 0);
    public static final CustomTime timeB = new CustomTime(2016, Month.APRIL, 12, 9, 0);

    public static final TemporalRange range1 = new TemporalRange(time1, time2);
    public static final TemporalRange range2 = new TemporalRange(time2, time3);
    public static final TemporalRange range3 = new TemporalRange(time3, time4);
    public static final TemporalRange range4 = new TemporalRange(time1, time3);
    public static final TemporalRange range5 = new TemporalRange(time2, time4);
    public static final TemporalRange range6 = new TemporalRange(time1, time4);
    public static final TemporalRange range7 = new TemporalRange(timeA, timeB);

    public static final Task task1 = new Task(null, "1", "", time1, time2);
    public static final Task task2 = new Task(null, "2", "", time2, time3);
    public static final Task task3 = new Task(null, "3", "", time3, time4);
    public static final Task task4 = new Task(null, "4", "", time1, time3);
    public static final Task task5 = new Task(null, "5", "", time2, time4);
    public static final Task task6 = new Task(null, "6", "", time1, time4);
    public static final Task task7 = new Task(null, "7", "", time5, time6);
    public static final Task task8 = new Task(null, "8", "", time7, time8);

    public static final Task partialTask1 = new Task(null, "a", "", time1, null);
    public static final Task partialTask2 = new Task(null, "b", "", time2, null);
    public static final Task partialTask3 = new Task(null, "c", "", null, time1);
    public static final Task partialTask4 = new Task(null, "d", "", null, time2);


    // dependency injection of Storage
    private Storage _storage;
    private Scheduler _scheduler;

    @Before
    public void setUp() {
        this._storage = new StorageTester();
        this._scheduler = new Scheduler(this._storage);
    }


    @Test
    public void Collapsing_disjoint_ranges_works() {
        List<TemporalRange> originalRanges = new LinkedList<>();
        List<TemporalRange> expectedRanges = new LinkedList<>();

        originalRanges.add(range1);
        originalRanges.add(range3);

        expectedRanges.add(range1);
        expectedRanges.add(range3);

        assertEquals(this._scheduler.collapseOverlappingRanges(originalRanges), expectedRanges);
    }

    @Test
    public void Collapsing_adjacent_ranges_works() {
        List<TemporalRange> originalRanges = new LinkedList<>();
        List<TemporalRange> expectedRanges = new LinkedList<>();

        originalRanges.add(range1);
        originalRanges.add(range2);
        originalRanges.add(range3);

        expectedRanges.add(range6);

        assertEquals(this._scheduler.collapseOverlappingRanges(originalRanges), expectedRanges);
    }

    @Test
    public void Collapsing_nested_ranges_works() {
        List<TemporalRange> originalRanges1 = new LinkedList<>(), originalRanges2 = new LinkedList<>();
        List<TemporalRange> expectedRanges1 = new LinkedList<>(), expectedRanges2 = new LinkedList<>();

        originalRanges1.add(range1);
        originalRanges1.add(range4);
        originalRanges2.add(range3);
        originalRanges2.add(range5);
        originalRanges2.add(range3);

        expectedRanges1.add(range4);
        expectedRanges2.add(range5);

        assertEquals(this._scheduler.collapseOverlappingRanges(originalRanges1), expectedRanges1);
        assertEquals(this._scheduler.collapseOverlappingRanges(originalRanges2), expectedRanges2);
    }

    @Test
    public void Collapsing_general_ranges_works() {
        List<TemporalRange> originalRanges = new LinkedList<>();
        List<TemporalRange> expectedRanges = new LinkedList<>();

        originalRanges.add(range4);
        originalRanges.add(range5);

        expectedRanges.add(range6);

        assertEquals(this._scheduler.collapseOverlappingRanges(originalRanges), expectedRanges);
    }

    @Test
    public void Collision_check_works_for_disjoint_tasks() {
        this._storage.save(task1);

        assertFalse(this._scheduler.isColliding(task3));
    }

    @Test
    public void Collision_check_works_for_adjacent_tasks() {
        this._storage.save(task1);
        this._storage.save(task2);

        assertFalse(this._scheduler.isColliding(task3));
    }

    @Test
    public void Collision_check_works_for_nested_tasks() {
        this._storage.save(task1);

        assertTrue(this._scheduler.isColliding(task4));
    }

    @Test
    public void Collision_check_works_for_general_tasks() {
        this._storage.save(task4);

        assertTrue(this._scheduler.isColliding(task5));
    }

    @Test
    public void Free_slot_computation_works_for_fully_defined_tasks() {
        this._storage.save(task1);
        this._storage.save(task3);

        List<TemporalRange> expectedFreeRange1 = new LinkedList<>(), expectedFreeRange2 = new LinkedList<>();

        expectedFreeRange1.add(range2);

        assertEquals(this._scheduler.getFreeSlots(time1, time4), expectedFreeRange1);
        assertEquals(this._scheduler.getFreeSlots(time2, time4), expectedFreeRange1);
        assertEquals(this._scheduler.getFreeSlots(time1, time3), expectedFreeRange1);
        assertEquals(this._scheduler.getFreeSlots(time2, time3), expectedFreeRange1);
        assertEquals(this._scheduler.getFreeSlots(time1, time2), expectedFreeRange2);
        assertEquals(this._scheduler.getFreeSlots(time3, time4), expectedFreeRange2);
    }

    @Test
    public void Free_slot_computation_works_for_partially_defined_tasks() {
        this._storage.save(partialTask1);
        this._storage.save(partialTask2);
        this._storage.save(task3);

        List<TemporalRange> expectedFreeRange = new LinkedList<>();

        expectedFreeRange.add(range4);

        assertEquals(this._scheduler.getFreeSlots(time1, time4), expectedFreeRange);
    }

    @Test
    public void Scheduler_works() {
        this._storage.save(task7);
        this._storage.save(task8);

        TemporalRange scheduledRange = this._scheduler.schedule(180);
        assertEquals(scheduledRange, range7);
    }
}
```
###### ./test/java/logic/TemporalRangeTest.java
``` java
 */
public class TemporalRangeTest {
    public static final CustomTime time1 = new CustomTime(2016, Month.APRIL, 1, 8, 0);
    public static final CustomTime time2 = new CustomTime(2016, Month.APRIL, 2, 16, 0);
    public static final CustomTime time3 = new CustomTime(2016, Month.APRIL, 3, 12, 0);
    public static final CustomTime time4 = new CustomTime(2016, Month.APRIL, 4, 7, 30);

    public static final TemporalRange range1 = new TemporalRange(time1, time2);
    public static final TemporalRange range2 = new TemporalRange(time2, time3);
    public static final TemporalRange range3 = new TemporalRange(time3, time4);
    public static final TemporalRange range4 = new TemporalRange(time1, time3);
    public static final TemporalRange range5 = new TemporalRange(time2, time4);
    public static final TemporalRange range6 = new TemporalRange(time1, time4);


    @Test
    public void Overlap_detection_works_for_non_overlapping_adjacent_ranges() {
        assertFalse(range1.overlaps(range2));
        assertFalse(range2.overlaps(range3));
        assertFalse(range2.overlaps(range1));
        assertFalse(range3.overlaps(range2));
    }

    @Test
    public void Overlap_detection_works_for_non_overlapping_non_adjacent_ranges() {
        assertFalse(range1.overlaps(range3));
        assertFalse(range3.overlaps(range1));
    }

    @Test
    public void Overlap_detection_works_for_overlapping_contained_ranges() {
        assertTrue(range4.overlaps(range1));
        assertTrue(range4.overlaps(range2));
        assertTrue(range5.overlaps(range2));
        assertTrue(range5.overlaps(range3));
        assertTrue(range1.overlaps(range4));
        assertTrue(range2.overlaps(range4));
        assertTrue(range2.overlaps(range5));
        assertTrue(range3.overlaps(range5));
    }

    @Test
    public void Overlap_detection_works_for_overlapping_non_contained_ranges() {
        assertTrue(range4.overlaps(range5));
        assertTrue(range5.overlaps(range4));
    }

    @Test
    public void Adjacency_detection_works_for_adjacent_ranges() {
        assertTrue(range1.isAdjacentTo(range2));
        assertTrue(range2.isAdjacentTo(range1));
        assertTrue(range2.isAdjacentTo(range3));
        assertTrue(range3.isAdjacentTo(range2));
    }

    @Test
    public void Merge_works_for_non_overlapping_adjacent_ranges() {
        assertEquals(range1.merge(range2), range4);
        assertEquals(range2.merge(range1), range4);
        assertEquals(range2.merge(range3), range5);
        assertEquals(range3.merge(range2), range5);
    }

    @Test
    public void Merge_works_for_overlapping_ranges() {
        assertEquals(range4.merge(range5), range6);
    }

    @Test
    public void Merge_gives_null_on_ranges_with_no_points_in_common() {
        assertNull(range1.merge(range3));
        assertNull(range3.merge(range1));
    }

    @Test
    public void Universal_range_works_as_intended() {
        assertEquals(TemporalRange.getUniversalRange().merge(range1), range1);
        assertEquals(range2.merge(TemporalRange.getUniversalRange()), range2);

        assertEquals(TemporalRange.getUniversalRange().merge(TemporalRange.getUniversalRange()), TemporalRange.getUniversalRange());
    }
}
```
