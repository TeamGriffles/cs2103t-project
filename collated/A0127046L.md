# A0127046L
###### ./main/java/exception/ExceptionHandler.java
``` java
 */
public class ExceptionHandler {
    private static ExceptionHandler instance = new ExceptionHandler();

    public static ExceptionHandler getInstance() {
        return instance;
    }

    private ExceptionHandler() {
    }

    public static void handle(Exception e) {
        e.printStackTrace();
    }
}
```
###### ./main/java/exception/PrimaryKeyNotFoundException.java
``` java
 */
public class PrimaryKeyNotFoundException extends Exception {
    /**
     *
     */
    private static final long serialVersionUID = -8577319752977443484L;
    /**
     * Properties
     */
    private final int _primaryKey;
    private final String STRING_MESSAGE_ERROR = "Primary key not found: ";

    /**
     * Constructs a new PrimaryKeyNotFoundException with the provided integer
     * primary key
     *
     * @param pKey
     *            an integer key
     */
    public PrimaryKeyNotFoundException(int pKey) {
        this._primaryKey = pKey;
    }

    @Override public String getMessage() {
        return this.STRING_MESSAGE_ERROR + this._primaryKey;
    }

}
```
###### ./main/java/launcher/Launcher.java
``` java
 */
public class Launcher extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    /**
     * Starts the application, initialising the full stack.
     * @param primaryStage the stage to be used for the application
     * @throws Exception
     */
    @Override public void start(Stage primaryStage) throws Exception {
        ApplicationContext.mainContext().setPrimaryStage(primaryStage);

        DispatcherSpec dispatcher = Dispatcher.getInstance();
        dispatcher.initialise();
        dispatcher.start();
    }
}
```
###### ./main/java/logic/CommandParser.java
``` java
 */
public class CommandParser implements CommandParserSpec {

    private static final String FILE_PARSER_DATA = "CommandParserData.json";

    public static final String MATCHER_GROUP_INSTRUCTION = "INST";
    private static final String MATCHER_GROUP_PREPOSITION_1 = "PREP1";
    private static final String MATCHER_GROUP_PREPOSITION_2 = "PREP2";
    public static final String MATCHER_GROUP_RELATIVE_TIME = "RELTIME";
    public static final String MATCHER_GROUP_DAY_OF_WEEK = "DOW";
    public static final String MATCHER_GROUP_DATE = "DATE";
    public static final String MATCHER_GROUP_TIME_OF_DAY = "TIME";
    public static final String MATCHER_GROUP_PRIORITY = "PRIO";
    private static final String MATCHER_GROUP_INDEX = "INDEX";
    private static final String MATCHER_GROUP_RANGE_START = "RSTART";
    private static final String MATCHER_GROUP_RANGE_END = "REND";
    private static final String MATCHER_GROUP_UNIVERSAL_QUANTIFIER = "UQ";
    private static final String MATCHER_GROUP_HOUR = "HOUR";
    private static final String MATCHER_GROUP_MINUTES = "MIN";
    private static final String MATCHER_GROUP_HOUR_DOT = "HDOT";

    private static final String STRING_INVALID_NAME_MISSING = "Task name is missing";
    private static final String STRING_INVALID_START_WITHOUT_END = "Task cannot have a start without an end";
    private static final String STRING_INVALID_EDIT_ID_MISSING = "You must tell me which task to edit";
    private static final String STRING_INVALID_RANGE_MISSING = "You must indicate an index or a range of tasks";
    private static final String STRING_INVALID_QUERY_MISSING = "You must specify a search query";
    private static final String STRING_INVALID_RANGE_FORMAT = "Invalid range";
    private static final String STRING_INVALID_SCHEDULE_ID_MISSING = "You must tell me which task to schedule";
    public static final String STRING_INVALID_DURATION_MISSING = "You must tell me how long you want your task to last!";

    /**
     * Singleton implementation
     */
    private static CommandParser instance = new CommandParser();
    public static CommandParser getInstance() {
        return instance;
    }

    /**
     * Properties
     */
    private ParserDefinitions _definitions;
    private String _instructionPattern;
    private String _startTimePattern;
    private String _endTimePattern;
    private String _priorityPattern;

    private CommandParser() {

    }

    @Override
    public void initialise() {
        this.readDataFromJson();
        this.constructRegularExpressions();
    }

    private void readDataFromJson() {
        // Create a JSON builder from the deserializer class
        GsonBuilder builder = new GsonBuilder();
        builder.registerTypeAdapter(
                ParserDefinitions.class,
                ParserDefinitionsDeserializer.getInstance());

        Gson gson = builder.create();

        // Read data from the file and parse it
        String definitionData = Resources.sharedResources().getDataFrom(FILE_PARSER_DATA);
        this._definitions = gson.fromJson(definitionData, ParserDefinitions.class);
    }

    //-------------------------------------------------------------------------------------------------
    //
    // REGULAR EXPRESSIONS construction
    //
    //-------------------------------------------------------------------------------------------------
    private void constructRegularExpressions() {
        this.constructInstructionRegExp();
        this.constructTimeRegExp();
        this.constructPriorityRegExp();
    }

    private void constructInstructionRegExp() {
        assert this._definitions != null && this._definitions.getInstructionKeywords() != null;
        this._instructionPattern = RegexUtils.startOfString(RegexUtils.wordBoundary(RegexUtils.namedChoice(
                MATCHER_GROUP_INSTRUCTION,
                this._definitions.getInstructionKeywords()
        )));
    }

    private void constructTimeRegExp() {
        this._startTimePattern = constructTimeRegexUsing(prep ->
                prep.getMeaning() != TimePreposition.Meaning.ENDING, false);
        this._endTimePattern = constructTimeRegexUsing(prep ->
                prep.getMeaning() != TimePreposition.Meaning.STARTING, true);
    }

    private String constructTimeRegexUsing(Predicate<? super TimePreposition> selectPredicate,
                                           boolean isPrepositionOptional) {
        //=====================================================================
        // UNCHAINABLE PREPOSITIONS
        //=====================================================================
        // Unchainable preposition is ALWAYS needed in the regular expression.
        // That leaves us with two alternatives: those with only one unchainable
        // preposition, and those with chainable prepositions. We consider the
        // former first
        String[] unchainablePrepositions = this._definitions.getTimePrepositions()
                .stream()
                .filter(selectPredicate)
                .filter(prep -> !prep.isChainable())
                .map(TimePreposition::getKeywords)
                .flatMap(Set::stream)
                .toArray(String[]::new);

        //=====================================================================
        // RELATIVE TIME
        //=====================================================================
        String[] relativeTimeNouns = this._definitions.getTimeNouns().stream()
                .filter(TimeNoun::isRelative)
                .map(TimeNoun::getKeywords)
                .flatMap(Set::stream)
                .toArray(String[]::new);

        //=====================================================================
        // ABSOLUTE DATE
        //=====================================================================
        // We bring in absolute date first because they cannot have a
        // chainable preposition in front of them, just like relative time
        String absoluteDates = RegexUtils.dateRegex();

        //=====================================================================
        // DAY OF WEEK
        //=====================================================================
        // Day of week type may opt to have a chainable preposition
        // in front of them
        String[] chainablePrepositions = this._definitions.getTimePrepositions()
                .stream()
                .filter(TimePreposition::isChainable)
                .filter(selectPredicate)
                .map(TimePreposition::getKeywords)
                .flatMap(Set::stream)
                .toArray(String[]::new);
        // Find out the absolute time nouns
        String[] dayOfWeeks = this._definitions.getTimeNouns().stream()
                .filter(noun -> !noun.isRelative())
                .map(TimeNoun::getKeywords)
                .flatMap(Set::stream)
                .toArray(String[]::new);
        //=====================================================================
        // TIME OF DAY
        //=====================================================================
        String timeOfDayPattern = "\\s+" + RegexUtils.namedGroup(
                MATCHER_GROUP_TIME_OF_DAY,
                RegexUtils.timeRegex()
        );

        String aggregatePattern = String.format("%1$s%2$s%3$s%4$s",
                // %1$s: Unchainable prepositions, optional based on
                // the condition specified in parameters
                isPrepositionOptional ? RegexUtils.optionalWord(RegexUtils.namedChoice(
                        MATCHER_GROUP_PREPOSITION_1,
                        unchainablePrepositions
                )) : RegexUtils.word(RegexUtils.namedChoice(
                        MATCHER_GROUP_PREPOSITION_1,
                        unchainablePrepositions
                )),
                // %2$s: Either relative time, exact date, or
                // a combination of a chainable preposition
                // (optional), and a day of week matcher
                RegexUtils.choice(
                        RegexUtils.namedChoice(
                                MATCHER_GROUP_RELATIVE_TIME,
                                relativeTimeNouns
                        ),
                        RegexUtils.namedChoice(
                                MATCHER_GROUP_DATE,
                                absoluteDates
                        ),
                        RegexUtils.optionalWord(RegexUtils.namedChoice(
                                MATCHER_GROUP_PREPOSITION_2,
                                chainablePrepositions
                        )).concat(RegexUtils.namedChoice(
                                MATCHER_GROUP_DAY_OF_WEEK,
                                dayOfWeeks
                        ))
                ),
                // %3$s: Optional, the English possessive suffix 's
                RegexUtils.optional("'s"),
                // %4$s: Optional, the time of the day
                RegexUtils.optional(timeOfDayPattern));

        // We don't want to parse this if it's wrapped within quotes
        aggregatePattern = RegexUtils.noSurroundingQuotes(aggregatePattern);

        return aggregatePattern;
    }

    private void constructPriorityRegExp() {
        String[] priorityKeywords = this._definitions.getPriorities().stream()
                .map(Priority::getKeywords)
                .flatMap(Set::stream)
                .toArray(String[]::new);

        this._priorityPattern = RegexUtils.word(
                RegexUtils.choice(this._definitions.getPriorityPrepositionKeywords())
        ).concat(RegexUtils.namedChoice(
                MATCHER_GROUP_PRIORITY,
                priorityKeywords
        ));
    }

    @Override
    public Command parse(String commandString) {
        // Construct the instruction first from the command string
        Matcher instructionMatcher = RegexUtils.caseInsensitiveMatch(
                this._instructionPattern,
                commandString);

        // Cannot find instruction, return unrecognised
        if (!instructionMatcher.find()) {
            return Command.unrecognisedCommand();
        }

        // Find out the instruction type and start parsing
        Command.Instruction instruction = this._definitions.queryInstruction(
                instructionMatcher.group(MATCHER_GROUP_INSTRUCTION).toLowerCase()
        );
        // Prepare a command object to start pushing parameters inside
        Command command = new Command(instruction);
        // Cut off the instruction to prepare for command parsing
        String partialCommand = commandString.substring(instructionMatcher.end()).trim();

        switch (instruction) {
            case ADD:
                command = this.parseAddCommand(command, partialCommand);
                break;
            case EDIT:
                command = this.parseEditCommand(command, partialCommand);
                break;
            case DELETE:
            case MARK:
                command = this.parseRangeCommand(command, partialCommand);
                break;
            case SEARCH:
                command = this.parseSearchCommand(command, partialCommand);
                break;
            case SCHEDULE:
                command = this.parseScheduleCommand(command, partialCommand);
                break;
        }

        return command;
    }

    private Command parseScheduleCommand(Command command, String partialCommand) {
        // Find index first
        Matcher indexMatcher = RegexUtils.caseInsensitiveMatch(
                this.getIndexRegex(),
                partialCommand
        );
        // No index found, return invalid command
        if (!indexMatcher.find()) {
            return Command.invalidCommand(STRING_INVALID_SCHEDULE_ID_MISSING);
        }

        // Set index first
        int taskId = Integer.parseInt(indexMatcher.group(MATCHER_GROUP_INDEX));
        command.setParameter(Command.ParamName.TASK_INDEX, taskId);

        // Truncate partial command string, with filler words too
        partialCommand = partialCommand.substring(indexMatcher.end()).trim();

        // Cut away filler words
        Matcher fillerMatcher = RegexUtils.caseInsensitiveMatch(
                RegexUtils.optionalWord("using"),
                partialCommand
        );
        if (fillerMatcher.find()) {
            partialCommand = partialCommand.substring(fillerMatcher.end()).trim();
        }

        // Get duration
        Matcher durationMatcher = RegexUtils.caseInsensitiveMatch(
                this.getDurationRegex(),
                partialCommand);

        int hour = 0;
        int minutes = 0;
        boolean matchFound = false;
        boolean hasDot = false;

        while (durationMatcher.find()) {
            matchFound = true;
            // Parse hour
            if (durationMatcher.group(MATCHER_GROUP_HOUR) != null) {
                hour = Integer.parseInt(durationMatcher.group(MATCHER_GROUP_HOUR));
                hasDot = false;
            }

            if (durationMatcher.group(MATCHER_GROUP_HOUR_DOT) != null) {
                hasDot = true;
            }

            // Parse minutes
            if (durationMatcher.group(MATCHER_GROUP_MINUTES) != null) {
                minutes = Integer.parseInt(durationMatcher.group(MATCHER_GROUP_MINUTES));

                // If the dot exists, we need to be able to find the minutes
                // in terms of decimal places
                if (minutes != 0 && hasDot) {
                    minutes = minutes * 6;
                }
            }
        }

        // If there is no duration, return error
        if (!matchFound) {
            return Command.invalidCommand(STRING_INVALID_DURATION_MISSING);
        }


        // Find the final duration and set it to the command
        int duration = hour * 60 + minutes;
        command.setParameter(Command.ParamName.TASK_DURATION, duration);

        return command;
    }

    /**
     * Attempts to parse the partial command string into a valid <code>ADD</code>
     * command.
     * @param command a command object
     * @param partialCommand a string containing parameters
     * @return the processed command
     */
    private Command parseAddCommand(Command command, String partialCommand) {
        // Start by finding the parameters, and keep track of the lowest
        // index found using the regex. Truncating from this index onwards will
        // give us the true task name
        int lowestFoundIndex = Math.min(
                this.parseTimeParameters(command, partialCommand),
                this.parsePriorityParameters(command, partialCommand)
        );

        String taskName = partialCommand.substring(0, lowestFoundIndex).trim();
        if (StringUtils.isSurroundedByQuotes(taskName)) {
            taskName = StringUtils.stripEndCharacters(taskName);
        }

        // Verify that task name is not null or empty
        if (taskName.trim().isEmpty()) {
            return Command.invalidCommand(STRING_INVALID_NAME_MISSING);
        }
        command.setParameter(Command.ParamName.TASK_NAME, taskName);

        // Verify that it must have an end if it has a start
        if (command.hasParameter(Command.ParamName.TASK_START) &&
                !command.hasParameter(Command.ParamName.TASK_END)) {
            return Command.invalidCommand(STRING_INVALID_START_WITHOUT_END);
        }
        return command;
    }

    private Command parseEditCommand(Command command, String partialCommand) {
        // Get the index first
        Matcher indexMatcher = RegexUtils.caseInsensitiveMatch(
                this.getIndexRegex(),
                partialCommand
        );
        // Verify index's existence
        if (!indexMatcher.find()) {
            return Command.invalidCommand(STRING_INVALID_EDIT_ID_MISSING);
        }

        // Set ID parameter first, then truncate task
        int taskId = Integer.parseInt(indexMatcher.group(MATCHER_GROUP_INDEX));
        command.setParameter(Command.ParamName.TASK_INDEX, taskId);
        partialCommand = partialCommand.substring(indexMatcher.end());

        // Parse time parameters next, keeping track of lowest index
        int lowestFoundIndex = Math.min(
                this.parseTimeParameters(command, partialCommand),
                this.parsePriorityParameters(command, partialCommand)
        );

        String taskName = partialCommand.substring(0, lowestFoundIndex).trim();
        if (StringUtils.isSurroundedByQuotes(taskName)) {
            taskName = StringUtils.stripEndCharacters(taskName);
        }

        // Keep the task name if it's not empty
        if (!taskName.trim().isEmpty()) {
            command.setParameter(Command.ParamName.TASK_NAME, taskName);
        }

        return command;
    }

    private Command parseRangeCommand(Command command, String partialCommand) {
        Matcher rangeMatcher = RegexUtils.caseInsensitiveMatch(
                this.getRangeRegex(),
                partialCommand
        );

        List<Range> rangeList = new ArrayList<>();

        while (rangeMatcher.find()) {
            if (rangeMatcher.group(MATCHER_GROUP_RANGE_START) != null) {
                // Create new range
                Range newRange = new Range(
                        Integer.parseInt(rangeMatcher.group(MATCHER_GROUP_RANGE_START))
                );
                rangeList.add(newRange);
            }

            if (rangeMatcher.group(MATCHER_GROUP_RANGE_END) != null) {
                // Hypothetically, the case when an end exists while there were no
                // previous range or the previous range already has an end is not
                // likely to happen, but we will catch it anyway
                if (rangeList.isEmpty() || rangeList.get(rangeList.size() - 1).hasEnd()) {
                    return Command.invalidCommand(STRING_INVALID_RANGE_FORMAT);
                }

                Range lastRange = rangeList.get(rangeList.size() - 1);
                lastRange.setEnd(
                        Integer.parseInt(rangeMatcher.group(MATCHER_GROUP_RANGE_END))
                );
            }
        }

        // If no match found, we attempt to find the universal quantifier instead
        if (rangeList.isEmpty()) {
            Matcher universalQuantifierMatcher = RegexUtils.caseInsensitiveMatch(
                    this.getUniversalQuantifierRegex(),
                    partialCommand
            );

            if (!universalQuantifierMatcher.find()) {
                // No universal quantifier found either, command is invalid!
                return Command.invalidCommand(STRING_INVALID_RANGE_MISSING);
            }

            // Set as universally quantified and exit straight away
            command.setParameter(Command.ParamName.TASK_UNIVERSALLY_QUANTIFIED, true);
            return command;
        }

        // Straighten the range first
        Range.straightenRanges(rangeList);

        // Set command parameters
        command.setParameter(Command.ParamName.TASK_INDEX_RANGES, rangeList);

        return command;
    }

    private Command parseSearchCommand(Command command, String partialCommand) {
        String fillerPattern = RegexUtils.optionalWord(
                RegexUtils.noSurroundingQuotes("for")
        );
        Matcher fillerMatcher = RegexUtils.caseInsensitiveMatch(
                fillerPattern,
                partialCommand
        );
        // Truncate up to filler
        if (fillerMatcher.find()) {
            partialCommand = partialCommand.substring(fillerMatcher.end()).trim();
        }
        // Remove quotes if required
        String searchQuery = partialCommand;
        if (StringUtils.isSurroundedByQuotes(searchQuery)) {
            searchQuery = StringUtils.stripEndCharacters(searchQuery);
        }

        if (searchQuery.trim().isEmpty()) {
            return Command.invalidCommand(STRING_INVALID_QUERY_MISSING);
        }

        // Set parameter and finish
        command.setParameter(Command.ParamName.SEARCH_QUERY, searchQuery);
        return command;
    }


    /**
     * TODO: Write JavaDoc
     * @param command
     * @param partialCommand
     * @return the lowest index that matches any time string
     */
    private int parseTimeParameters(Command command, String partialCommand) {
        // Keep track of the lowest found index
        int lowestFoundIndex = partialCommand.length();
        // Also keep track of the highest found index so that end time
        // can be differentiated from start time
        int highestFoundIndex = 0;

        // Prepare time variables
        CustomTime startTime = null;
        CustomTime endTime = null;

        // Match start time
        Matcher startTimeMatcher = RegexUtils.caseInsensitiveMatch(
                this._startTimePattern,
                partialCommand
        );
        if (startTimeMatcher.find()) {
            startTime = new CustomTime(
                    this.parseDate(startTimeMatcher),
                    this.parseTime(startTimeMatcher)
            );

            // Save the highest and lowest found index
            if (startTimeMatcher.end() > highestFoundIndex) {
                highestFoundIndex = startTimeMatcher.end();
            }
            if (startTimeMatcher.start() < lowestFoundIndex) {
                lowestFoundIndex = startTimeMatcher.start();
            }
        }

        // Match end time
        Matcher endTimeMatcher = RegexUtils.caseInsensitiveMatch(
                this._endTimePattern,
                partialCommand
        );
        if (endTimeMatcher.find(highestFoundIndex)) {
            endTime = new CustomTime(
                    this.parseDate(endTimeMatcher),
                    this.parseTime(endTimeMatcher)
            );
            if (endTimeMatcher.start() < lowestFoundIndex) {
                lowestFoundIndex = endTimeMatcher.start();
            }
        }

        // Finally register the time to the command object
        if (startTime != null && !startTime.isNullDate()) {
            command.setParameter(Command.ParamName.TASK_START, startTime);
        }
        if (endTime != null && !endTime.isNullDate()) {
            command.setParameter(Command.ParamName.TASK_END, endTime);
        }

        // return the lowest found index
        return lowestFoundIndex;
    }

    private int parsePriorityParameters(Command command, String partialCommand) {
        Matcher matcher = RegexUtils.caseInsensitiveMatch(
                this._priorityPattern,
                partialCommand
        );
        // If cannot find, return lowest found to be string length
        if (!matcher.find()) {
            return partialCommand.length();
        }

        Task.Priority priority = this._definitions.queryPriority(
                matcher.group(MATCHER_GROUP_PRIORITY).toLowerCase()
        );
        command.setParameter(Command.ParamName.PRIORITY_VALUE, priority);

        return matcher.start();
    }

    private LocalDate parseDate(Matcher matcher) {
        // There are 3 cases:
        //     I. There is a relative time (now, today, same day, etc)
        //    II. There is a day of week (mon, tue, etc)
        //   III. There is an absolute date (Mar 21 2016 etc)

        //=====================================================================
        // I. RELATIVE TIME
        //=====================================================================
        if (matcher.group(MATCHER_GROUP_RELATIVE_TIME) != null) {
            String relativeTimeString = matcher.group(MATCHER_GROUP_RELATIVE_TIME)
                    .trim().toLowerCase();
            TimeNoun.Relative meaning = this._definitions.queryRelativeDate(relativeTimeString);
            switch (meaning) {
                case NOW:
                case TODAY:
                    return LocalDate.now();
                case TOMORROW:
                    return LocalDate.now().plusDays(1);
                default:
                    return null;
            }
        }

        //=====================================================================
        // II. DAY OF WEEK
        //=====================================================================
        if (matcher.group(MATCHER_GROUP_DAY_OF_WEEK) != null) {
            // Find out if the prepositions tell us that we should look for the
            // next week's instant instead
            boolean isNextWeek = false;

            isNextWeek = this.isImplyingNextWeek(matcher.group(MATCHER_GROUP_PREPOSITION_1));
            isNextWeek = this.isImplyingNextWeek(matcher.group(MATCHER_GROUP_PREPOSITION_2));

            // Get the day of week first
            DayOfWeek dayToConsider = this._definitions.queryDayOfWeek(
                    matcher.group(MATCHER_GROUP_DAY_OF_WEEK).trim().toLowerCase()
            );

            // In some cases, next week's might mean this week! For example, if today is
            // Sunday, then next Monday will mean tomorrow (the currently upcoming Monday!).
            // If this week's instance of the day is already past, then next actually
            // means current
            DayOfWeek today = LocalDate.now().getDayOfWeek();

            if (isNextWeek && dayToConsider.getValue() <= today.getValue()) {
                isNextWeek = false;
            }

            // Now that we are certain what we want, let's find the date!
            CustomTime temporary = CustomTime.now();
            if (!isNextWeek) {
                // Current week
                return temporary.current(dayToConsider).getDate();
            } else {
                // Next week
                return temporary.next(dayToConsider).getDate();
            }
        }

        //=====================================================================
        // III. ABSOLUTE DATE
        //=====================================================================
        if (matcher.group(MATCHER_GROUP_DATE) != null) {
            String day = matcher.group(RegexUtils.MATCHER_GROUP_DATE_DAY);
            String month = matcher.group(RegexUtils.MATCHER_GROUP_DATE_MONTH);
            String year = matcher.group(RegexUtils.MATCHER_GROUP_DATE_YEAR);

            // TODO: Catch this error
            // We don't want the date and the month to be null
            if (day == null || month == null) {
                return null;
            }

            int dayValue = Integer.parseInt(day);
            // Linear search through the months to find the correct month
            // We only want the first 3 letters for comparison (because
            // at the minimum the month will be recognised by its first
            // 3 characters)
            final String shortMonth = month.substring(0, 3);
            Month monthValue = Arrays.stream(Month.values())
                    .filter(m -> m.name().substring(0, 3).equalsIgnoreCase(shortMonth))
                    .findFirst()
                    .orElse(null); // This should not happen

            int yearValue = year != null ? Integer.parseInt(year) :
                    LocalDate.now().getYear();

            return LocalDate.of(yearValue, monthValue, dayValue);
        }

        // Nothing found, return null
        return null;
    }

    private LocalTime parseTime(Matcher matcher) {
        // Cannot find time of day
        if (matcher.group(MATCHER_GROUP_TIME_OF_DAY) == null) {
            return null;
        }
        // Lower the string and remove any colon
        String time = matcher.group(MATCHER_GROUP_TIME_OF_DAY)
                .toLowerCase().replace(":", "");
        boolean isPM = time.contains("pm");
        // Now that we have saved whether the string contains the word PM
        // or not, we can proceed on to discard it and parse the time
        int integerTime = Integer.parseInt(time.replaceAll("[^0-9]", ""));

        // Try to get the time. We will regard anything greater than 100
        // as following the HH:mm format, while the rest should be treated
        // as just hours and without minutes
        int hour = integerTime >= 100 ? integerTime / 100 : integerTime;
        if (hour < 12 && isPM) {
            hour += 12;
        }
        // TODO: Catch this error
        // Invalid hour, we return null
        if (hour >= 24) {
            return null;
        }

        ChronoUnit precision = ChronoUnit.HOURS;
        int minute = 0;
        if (integerTime >= 100) {
            minute = integerTime % 100;
            precision = ChronoUnit.MINUTES;
        }

        return LocalTime.of(hour, minute);
    }

    private boolean isImplyingNextWeek(String preposition) {
        // Non-existent, cannot imply
        if (preposition == null) {
            return false;
        }
        preposition = preposition.trim().toLowerCase();
        TimePreposition.Meaning meaning = this._definitions.queryTimePreposition(preposition);
        return meaning == TimePreposition.Meaning.NEXT;
    }

    private String getIndexRegex() {
        return String.format("^(?:task\\s+)?(?:number(?:ed)?\\s+)?(?<%s>\\d+)",
                MATCHER_GROUP_INDEX);
    }

    private String getRangeRegex() {
        return String.format("(?:all\\s+)?(?:task(?:s)?\\s+)?(?:number(?:ed)?\\s+)?" +
                        "(?:(?<%s>\\d+)(?:\\s*(?:to|-)\\s*(?<%s>\\d+))?)",
                MATCHER_GROUP_RANGE_START,
                MATCHER_GROUP_RANGE_END);
    }

    private String getUniversalQuantifierRegex() {
        return RegexUtils.startOfString(RegexUtils.namedChoice(
                MATCHER_GROUP_UNIVERSAL_QUANTIFIER,
                "all", "everything"
        ));
    }

    private String getDurationRegex() {
        // This will be used for capturing the dot
        String timeDelimiterPattern1 = RegexUtils.unbracketedChoice(
                "h", "\\s+hour(?:s)?\\s+", RegexUtils.namedGroup(
                        MATCHER_GROUP_HOUR_DOT, "\\."
                )
        );
        // This will not, just for negative lookahead
        String timeDelimiterPattern2 = RegexUtils.unbracketedChoice(
                "h", "\\s+hour(?:s)?\\s+", "\\."
        );

        // Construct the patterns
        String hourPattern = RegexUtils.namedGroup(
                MATCHER_GROUP_HOUR,
                RegexUtils.positiveLookahead(
                        "\\d+",
                        timeDelimiterPattern1
                )
        );
        String minutesPattern = RegexUtils.namedGroup(
                MATCHER_GROUP_MINUTES,
                RegexUtils.negativeLookahead(
                        "\\d+",
                        timeDelimiterPattern2
                )
        );
        return RegexUtils.unbracketedChoice(
                hourPattern, minutesPattern
        );
    }

    //-------------------------------------------------------------------------------------------------
    //
    // GETTERS for constructed regexp
    //
    //-------------------------------------------------------------------------------------------------
    public String getInstructionPattern() {
        return this._instructionPattern;
    }

    public String getStartTimePattern() {
        return this._startTimePattern;
    }

    public String getEndTimePattern() {
        return this._endTimePattern;
    }

    public String getPriorityPattern() {
        return this._priorityPattern;
    }
}
```
###### ./main/java/logic/parser/Instruction.java
``` java
 */
public class Instruction {

    private static final String KEY_JSON_NAME = "name";
    private static final String KEY_JSON_KEYWORDS = "keywords";

    private Command.Instruction _name;
    private Set<String> _keywords;

    public Instruction(JsonObject instructionObject) {
        assert instructionObject.has(KEY_JSON_NAME);
        assert instructionObject.has(KEY_JSON_KEYWORDS);

        // Parse name
        this._name = JsonUtils.findEnumValue(
                instructionObject.get(KEY_JSON_NAME).getAsString(),
                Command.Instruction.class
        );

        // Parse keywords
        this._keywords = JsonUtils.toStringSet(
                instructionObject.get(KEY_JSON_KEYWORDS).getAsJsonArray()
        );
    }

    public Command.Instruction getName() {
        return this._name;
    }

    public Set<String> getKeywords() {
        return this._keywords;
    }
}
```
###### ./main/java/logic/parser/JsonUtils.java
``` java
 */
public class JsonUtils {

    public static Set<String> toStringSet(JsonArray array) {
        String[] stringArray = new String[array.size()];
        for (int i = 0; i < array.size(); i++) {
            stringArray[i] = array.get(i).getAsString();
        }
        return Arrays.stream(stringArray).collect(Collectors.toSet());
    }

    public static <E extends Enum> E findEnumValue(String enumName, Class<E> enumClass) {
        return Arrays.stream(enumClass.getEnumConstants())
                .filter(constant -> constant.name().equals(enumName))
                .findFirst().orElse(null);
    }
}
```
###### ./main/java/logic/parser/ParserDefinitions.java
``` java
 */
public class ParserDefinitions {

    /**
     * Properties
     */

    // Instructions
    private List<Instruction> _instructions;
    private LinkedHashMap<String, Command.Instruction> _instructionTranslator;

    // Time Prepositions
    private List<TimePreposition> _timePrepositions;
    private LinkedHashMap<String, TimePreposition.Meaning> _timePrepositionTranslator;

    // Time Nouns
    private List<TimeNoun> _timeNouns;
    private LinkedHashMap<String, TimeNoun.Relative> _relativeTimeTranslator;
    private LinkedHashMap<String, DayOfWeek> _absoluteTimeTranslator;

    // Priority (plus Prepositions)
    private Set<String> _priorityPrepositions;
    private List<Priority> _priorities;
    private LinkedHashMap<String, Task.Priority> _priorityTranslator;

    // Caching behaviours
    private String[] _cachedInstructionKeywords;
    private String[] _cachedPriorityPrepositionKeywords;

    public ParserDefinitions() {
        this._instructionTranslator = new LinkedHashMap<>();
        this._timePrepositionTranslator = new LinkedHashMap<>();
        this._relativeTimeTranslator = new LinkedHashMap<>();
        this._absoluteTimeTranslator = new LinkedHashMap<>();
        this._priorityTranslator = new LinkedHashMap<>();
    }

    //-------------------------------------------------------------------------------------------------
    //
    // SETTER METHODS
    //
    //-------------------------------------------------------------------------------------------------
    /**
     * Registers a set of instructions to be used under this definition.
     * @param instructions a set of {@link Instruction}
     */
    public void setInstructions(List<Instruction> instructions) {
        this._instructions = instructions;

        instructions.stream().forEach(instruction -> {
            instruction.getKeywords().stream().forEach(keyword -> {
                this._instructionTranslator.put(
                        keyword,
                        instruction.getName());
            });
        });
    }

    /**
     * Registers a set of time prepositions to be used under this definition.
     * @param prepositions a set of {@link TimePreposition}
     */
    public void setTimePrepositions(List<TimePreposition> prepositions) {
        this._timePrepositions = prepositions;

        // Populate time prepositions translation
        prepositions.stream().forEach(preposition -> {
            preposition.getKeywords().forEach(keyword -> {
                this._timePrepositionTranslator.put(
                        keyword,
                        preposition.getMeaning());
            });
        });
    }

    /**
     * Registers a set of time nouns to be used under this definition. This method
     * populates both relative and absolute time nouns.
     * @param nouns a set of {@link TimeNoun}
     */
    public void setTimeNouns(List<TimeNoun> nouns) {
        this._timeNouns = nouns;

        // Populate relative time nouns translation
        nouns.stream().filter(TimeNoun::isRelative).forEach(noun -> {
            noun.getKeywords().forEach(keyword -> {
                this._relativeTimeTranslator.put(
                        keyword,
                        noun.getRelativeMeaning()
                );
            });
        });

        // Populate absolute time nouns translation
        nouns.stream().filter(noun -> !noun.isRelative()).forEach(noun -> {
            noun.getKeywords().forEach(keyword -> {
                this._absoluteTimeTranslator.put(
                        keyword,
                        noun.getAbsoluteMeaning()
                );
            });
        });
    }

    /**
     * Registers a set of priority preposition keywords to be used under this
     * definition.
     * @param prepositions a set of preposition keywords
     */
    public void setPriorityPrepositions(Set<String> prepositions) {
        this._priorityPrepositions = prepositions;
    }

    /**
     * Registers a set of priority nouns to be used under this definition.
     * @param priorities a set of {@link Priority}
     */
    public void setPriorities(List<Priority> priorities) {
        this._priorities = priorities;

        // Populate priorities translation
        priorities.stream().forEach(priority -> {
            priority.getKeywords().forEach(keyword -> {
                this._priorityTranslator.put(
                        keyword,
                        priority.getMeaning());
            });
        });
    }

    //-------------------------------------------------------------------------------------------------
    //
    // GETTER METHODS
    //
    //-------------------------------------------------------------------------------------------------
    public String[] getInstructionKeywords() {
        if (this._cachedInstructionKeywords == null) {
            this._cachedInstructionKeywords = this._instructions.stream()
                    .map(Instruction::getKeywords)
                    .flatMap(Set::stream)
                    .toArray(String[]::new);
        }
        return this._cachedInstructionKeywords;
    }

    public List<TimePreposition> getTimePrepositions() {
        return this._timePrepositions;
    }

    public List<TimeNoun> getTimeNouns() {
        return this._timeNouns;
    }

    public Set<TimeNoun> getRelativeDates() {
        return this.getTimeNouns().stream()
                .filter(TimeNoun::isRelative)
                .collect(Collectors.toSet());
    }

    public String[] getPriorityPrepositionKeywords() {
        if (this._cachedPriorityPrepositionKeywords == null) {
            this._cachedPriorityPrepositionKeywords = this._priorityPrepositions
                    .stream().toArray(String[]::new);
        }
        return this._cachedPriorityPrepositionKeywords;
    }

    public List<Priority> getPriorities() {
        return this._priorities;
    }

    public Command.Instruction queryInstruction(String instruction) {
        return this._instructionTranslator.get(instruction);
    }

    public TimeNoun.Relative queryRelativeDate(String date) {
        return this._relativeTimeTranslator.get(date);
    }

    public TimePreposition.Meaning queryTimePreposition(String preposition) {
        return this._timePrepositionTranslator.get(preposition);
    }

    public DayOfWeek queryDayOfWeek(String dayOfWeekString) {
        return this._absoluteTimeTranslator.get(dayOfWeekString);
    }

    public Task.Priority queryPriority(String priority) {
        return this._priorityTranslator.get(priority);
    }
}
```
###### ./main/java/logic/parser/ParserDefinitionsDeserializer.java
``` java
 */
public class ParserDefinitionsDeserializer implements JsonDeserializer<ParserDefinitions> {
    /**
     * Constants
     */
    private static final String KEY_JSON_INSTRUCTIONS = "instructions";
    private static final String KEY_JSON_TIME_PREPOSITIONS = "timePrepositions";
    private static final String KEY_JSON_TIME_NOUNS = "timeNouns";
    private static final String KEY_JSON_PRIORITY_PREPOSITIONS = "priorityPrepositions";
    private static final String KEY_JSON_PRIORITY_NOUNS = "priorities";

    /**
     * Singleton implementation
     */
    private static ParserDefinitionsDeserializer instance = new ParserDefinitionsDeserializer();
    public static ParserDefinitionsDeserializer getInstance() {
        return instance;
    }
    private ParserDefinitionsDeserializer() {
    }

    @Override
    public ParserDefinitions deserialize(JsonElement json,
                                         Type typeOfT,
                                         JsonDeserializationContext context) throws JsonParseException {
        // Convert the entire element into a JSON object
        JsonObject definitionObject = json.getAsJsonObject();

        // Parse individual arrays of objects
        List<Instruction> instructions = this.getObjectsFromKey(
                KEY_JSON_INSTRUCTIONS, Instruction.class, definitionObject);
        List<TimePreposition> timePrepositions = this.getObjectsFromKey(
                KEY_JSON_TIME_PREPOSITIONS, TimePreposition.class, definitionObject);
        List<TimeNoun> timeNouns = getObjectsFromKey(
                KEY_JSON_TIME_NOUNS, TimeNoun.class, definitionObject);
        Set<String> priorityPrepositions = JsonUtils.toStringSet(
                definitionObject.get(KEY_JSON_PRIORITY_PREPOSITIONS).getAsJsonArray()
        );
        List<Priority> priorities = this.getObjectsFromKey(
                KEY_JSON_PRIORITY_NOUNS, Priority.class, definitionObject);

        // Finally, populate the definition object with the necessary definitions
        ParserDefinitions definitions = new ParserDefinitions();
        definitions.setInstructions(instructions);
        definitions.setTimePrepositions(timePrepositions);
        definitions.setTimeNouns(timeNouns);
        definitions.setPriorityPrepositions(priorityPrepositions);
        definitions.setPriorities(priorities);

        return definitions;
    }

    private <T> List<T> getObjectsFromKey(String key, Class<T> objectClass, JsonObject object) {
        return this.parseJsonArray(
                object.get(key).getAsJsonArray(),
                objectClass
        );
    }

    private <T> List<T> parseJsonArray(JsonArray array, Class<T> objectClass) {
        return IntStream.range(0, array.size())
                .mapToObj(array::get)
                .map(JsonElement::getAsJsonObject)
                .map(object -> this.constructFromJsonObject(object, objectClass))
                .filter(object -> object != null)
                .collect(Collectors.toList());
    }

    private <T> T constructFromJsonObject(JsonObject object, Class<T> objectClass) {
        try {
            return (T) objectClass.getConstructor(JsonObject.class).newInstance(object);
        } catch (Exception e) {
            ExceptionHandler.handle(e);
            return null;
        }
    }
}
```
###### ./main/java/logic/parser/Priority.java
``` java
 */
public class Priority {
    private static final String KEY_JSON_MEANING = "meaning";
    private static final String KEY_JSON_KEYWORDS = "keywords";

    private Task.Priority _meaning;
    private Set<String> _keywords;

    public Priority(JsonObject priorityObject) {
        assert priorityObject.has(KEY_JSON_MEANING);
        assert priorityObject.has(KEY_JSON_KEYWORDS);

        // Parse meaning
        this._meaning = JsonUtils.findEnumValue(
                priorityObject.get(KEY_JSON_MEANING).getAsString(),
                Task.Priority.class
        );

        // Parse keywords
        this._keywords = JsonUtils.toStringSet(
                priorityObject.get(KEY_JSON_KEYWORDS).getAsJsonArray()
        );
    }

    // Getters
    public Task.Priority getMeaning() {
        return this._meaning;
    }

    public Set<String> getKeywords() {
        return this._keywords;
    }
}
```
###### ./main/java/logic/parser/RegexUtils.java
``` java
 */
public class RegexUtils {

    private static final String DELIMITER_CHOICES = "|";
    public static final String MATCHER_GROUP_DATE_YEAR = "YEAR";
    public static final String MATCHER_GROUP_DATE_DAY = "DAY";
    public static final String MATCHER_GROUP_DATE_MONTH = "MONTH";

    /**
     * Constructs a Pattern that uses the Regular Expression inside the
     * pattern
     * @param pattern
     * @return
     */
    public static Pattern caseInsensitive(String pattern) {
        return Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
    }

    /**
     * Constructs a matcher that matches the test string case-insensitively
     * with the RegExp pattern given.
     * @param pattern a regex string
     * @param testString a string to be tested for matches
     * @return a matcher that matches the string with the regex
     */
    public static Matcher caseInsensitiveMatch(String pattern, String testString) {
        return caseInsensitive(pattern).matcher(testString);
    }

    /**
     * Constructs a RegExp that matches any string in the choices given.
     * @param choices a vararg array of different strings that can be matched
     * @return a RegExp string that matches any choice given
     */
    public static String choice(String... choices) {
        return String.format("(?:%s)", unbracketedChoice(choices));
    }

    /**
     * Constructs a RegExp that matches any string in the choices given, but
     * without surrounding brackets.
     * @param choices a vararg array of different strings that can be matched
     * @return a RegExp string that matches any choice given, without brackets
     */
    public static String unbracketedChoice(String... choices) {
        // We want the longer strings to be matched first
        Arrays.sort(choices, (string1, string2) -> string2.length() - string1.length());
        return String.join(DELIMITER_CHOICES, choices);
    }

    /**
     * Constructs a RegExp that matches any choice given, which will be captured
     * under the named group denoted by the <code>name</code> string.
     * @param name the name of the capturing group
     * @param choices a vararg array of different strings that can be matched
     * @return a RegExp string that captures any choice given under a named group
     */
    public static String namedChoice(String name, String... choices) {
        assert name != null && !name.trim().isEmpty();

        // We want the longer strings to be matched first
        Arrays.sort(choices, (string1, string2) -> string2.length() - string1.length());

        return String.format("(?<%s>%s)", name,
                String.join(DELIMITER_CHOICES, choices));
    }

    /**
     * Constructs a RegExp that matches a string only when it is the start
     * of the starting string (we allow spaces in front).
     * @param string the string to be considered as starting
     * @return a RegExp string that only matches if <code>string</code>
     * is at the start of the tested string
     */
    public static String startOfString(String string) {
        return "^\\s*" + string;
    }

    /**
     * Constructs a RegExp that matches even when the provided string does
     * not exist inside the candidate string.
     * @param string an optional string
     * @return a RegExp that matches regardless of whether the provided
     * string exists or not
     */
    public static String optional(String string) {
        return String.format("(?:%s)?", string);
    }

    /**
     * Constructs a RegExp that matches similarly to optional, but with
     * compulsory trailing spaces if the word actually exists.
     * @param word an optional word
     * @return a RegExp that matches regardless of whether the provided
     * word exists or not
     */
    public static String optionalWord(String word) {
        return optional(word(word));
    }

    /**
     * Constructs a RegExp that matches the given word string followed by
     * compulsory trailing spaces.
     * @param word
     * @return
     */
    public static String word(String word) {
        return word + "\\s+";
    }

    /**
     * Constructs a RegExp from an existing RegExp that makes the original
     * one not matchable if it's between quotes.
     * @param currentRegex the original regular expression
     * @return the modified RegExp string
     */
    public static String noSurroundingQuotes(String currentRegex) {
        return currentRegex.concat("(?=(?:(?:(?:[^\"\\\\]++|\\\\.)*+\"){2})*+(?:[^\"\\\\]++|\\\\.)*+$)");
    }

    /**
     * Wraps an existing RegExp in a named capturing group.
     * @param name a string denoting the name of the group
     * @param group an existing regular expression
     * @return a named capturing group
     */
    public static String namedGroup(String name, String group) {
        return String.format("(?<%s>%s)", name, group);
    }

    /**
     * Creates a RegExp that matches calendar date (with textual month)
     * @return a calendar date reg exp
     */
    public static String dateRegex() {
        // Year
        String yearPattern = "\\d{4}";
        String fullYearPattern = namedGroup(
                MATCHER_GROUP_DATE_YEAR,
                yearPattern
        );

        // Day
        String dayPattern = "\\b\\d{1,2}";
        String fullDayPattern = negativeLookahead(String.format("%s%s\\b",
                namedGroup(MATCHER_GROUP_DATE_DAY, dayPattern),
                optional(choice("st", "nd", "rd", "th"))), unbracketedChoice("am", "pm"));

        // Month
        String[] monthStrings = Arrays.stream(Month.values())
                .map(Month::name)
                .map(String::toLowerCase)
                .flatMap(fullMonthString -> Arrays.asList(
                        fullMonthString,
                        fullMonthString.substring(0, 3)
                ).stream())
                .toArray(String[]::new);
        String fullMonthPattern = namedChoice(
                MATCHER_GROUP_DATE_MONTH,
                monthStrings
        );

        // Separator
        String separatorPattern = optional(choice("\\s","\\/", "-"));

        return RegexUtils.choice(Arrays.asList(
                fullYearPattern,
                fullDayPattern,
                fullMonthPattern
        ).stream().map(pattern -> pattern.concat(separatorPattern))
                .toArray(String[]::new)).concat("{2,3}");
    }

    /**
     * Creates a RegExp that matches time of a day.
     * @return a time of day regular expression
     */
    public static String timeRegex() {
        return "(?:\\d|:(?=\\d(?<=\\d))){1,5}(?:\\s*(?:am|pm))?";
    }

    /**
     * Creates a RegExp that matches only when the word stands alone between spaces
     * @param word the word to assert boundary
     * @return a regular expression that check if word satisfy boundary check
     */
    public static String wordBoundary(String word) {
        return String.format("\\b%s\\b", word);
    }

    public static String positiveLookahead(String pattern, String lookahead) {
        return String.format("%s(?=%s)", pattern, lookahead);
    }

    public static String negativeLookahead(String pattern, String lookahead) {
        return String.format("%s(?!%s)", pattern, lookahead);
    }
}
```
###### ./main/java/logic/parser/TimeNoun.java
``` java
 */
public class TimeNoun {
    /**
     * Constants
     */
    private static final String KEY_JSON_MEANING = "meaning";
    private static final String KEY_JSON_KEYWORDS = "keywords";
    private static final String KEY_JSON_PREPOSITIONS = "prepositions";

    /**
     * Types
     */
    public enum Relative {
        NOW, TODAY, TOMORROW, SAME_DAY
    }

    /**
     * Properties
     */
    private boolean _isRelative;
    private Relative _relativeMeaning;
    private DayOfWeek _absoluteMeaning;
    private Set<String> _keywords;
    private Set<TimePreposition.Meaning> _prepositions;
    private boolean _canGoWithoutPrepositions;

    /**
     * Constructs a time noun from the JSON data.
     * @param nounObject a JSON object containing the data for the time noun
     */
    public TimeNoun(JsonObject nounObject) {
        assert nounObject.has(KEY_JSON_MEANING);
        assert nounObject.has(KEY_JSON_KEYWORDS);
        assert nounObject.has(KEY_JSON_PREPOSITIONS);

        // Parse meaning
        String meaning = nounObject.get(KEY_JSON_MEANING).getAsString();
        // Look for the meaning inside the relative nouns list
        this._relativeMeaning = JsonUtils.findEnumValue(meaning, Relative.class);
        // Check whether it's null, and if it is we continue to look for this value
        // inside the absolute days of week list
        if (!(this._isRelative = (this._relativeMeaning != null))) {
            this._absoluteMeaning = JsonUtils.findEnumValue(meaning, DayOfWeek.class);
        }

        // Parse keywords
        this._keywords = JsonUtils.toStringSet(nounObject.get(KEY_JSON_KEYWORDS).getAsJsonArray());

        // Parse set of preposition meanings
        this._prepositions = JsonUtils.toStringSet(nounObject.get(KEY_JSON_PREPOSITIONS).getAsJsonArray())
                .stream()
                .map(prep -> JsonUtils.findEnumValue(prep, TimePreposition.Meaning.class))
                .collect(Collectors.toSet());
    }

    public boolean isRelative() {
        return this._isRelative;
    }

    public Relative getRelativeMeaning() {
        assert this._isRelative;
        return this._relativeMeaning;
    }

    public DayOfWeek getAbsoluteMeaning() {
        assert !this._isRelative;
        return this._absoluteMeaning;
    }

    public Set<String> getKeywords() {
        return this._keywords;
    }

    public Set<TimePreposition.Meaning> getPrepositions() {
        return this._prepositions;
    }

}
```
###### ./main/java/logic/parser/TimePreposition.java
``` java
 */
public class TimePreposition {
    private static final String KEY_JSON_MEANING = "meaning";
    private static final String KEY_JSON_KEYWORDS = "keywords";
    private static final String KEY_JSON_CHAINABLE = "chainable";

    public enum Meaning {
        CURRENT, NEXT, STARTING, ENDING
    }

    private Meaning _meaning;
    private Set<String> _keywords;
    private boolean _isChainable;

    public TimePreposition(JsonObject prepObject) {
        assert prepObject.has(KEY_JSON_MEANING);
        assert prepObject.has(KEY_JSON_KEYWORDS);
        assert prepObject.has(KEY_JSON_CHAINABLE);

        // Parse meaning
        this._meaning = JsonUtils.findEnumValue(
                prepObject.get(KEY_JSON_MEANING).getAsString(),
                Meaning.class
        );
        assert this._meaning != null;

        // Parse keywords
        this._keywords = JsonUtils.toStringSet(prepObject.get(KEY_JSON_KEYWORDS).getAsJsonArray());

        // Parse chainability
        this._isChainable = prepObject.get(KEY_JSON_CHAINABLE).getAsBoolean();
    }

    // Getters
    public Meaning getMeaning() {
        return this._meaning;
    }

    public Set<String> getKeywords() {
        return this._keywords;
    }

    public boolean isChainable() {
        return this._isChainable;
    }
}
```
###### ./main/java/logic/TranslationEngine.java
``` java
 */
public class TranslationEngine implements TranslationEngineSpec {
    /**
     * Singleton instance
     */
    private static TranslationEngine instance;

    /**
     * Properties
     */
    private Function<Command, ExecutionResult> _commandExecutionHandler;
    private Command _lastCommand;

    /**
     * Private constructor
     */
    private TranslationEngine() {
        this._lastCommand = null;
    }

    /**
     * Singleton getter
     * Check if there is already an instance of TranslaitionEngine. If it exists, return that particular instance. Else
     * instantiate a new TranslationEngine.
     *
     * @return an instance of TranslationEngine.
     */
    public static TranslationEngine getInstance() {
        if (instance == null) {
            instance = new TranslationEngine();
        }
        return instance;
    }

    @Override public void setCommandExecutionHandler(Function<Command, ExecutionResult> handler) {
        assert (handler != null);
        this._commandExecutionHandler = handler;
    }

    @Override public void initialise() {
        // Trigger initialisation of CommandParser
        this.getCommandParser().initialise();

        // Create input handler
        Function<String, Void> commandInputHandler = commandString -> {
            // Translate the raw command string given
            this.translateCommand(commandString);
            return null;
        };

        // Attach input handler to user interface
        UserInterfaceSpec ui = this.getUserInterface();
        ui.setOnCommandInputHandler(commandInputHandler);
        ui.initialize();
        ui.show();
    }

    /**
     * This method will display the result of the User's Command back to the user through the GUI.
     * Translation Engine will generate the appropriate view to the type of result yielded.
     *
     * @param result ExecutionResult containing data that is going to be translated to a GUI display
     */
    @Override public void displayResult(ExecutionResult result) {
        if (result.isShutdownSignal()) {
            // Do not display shutdown signal
            return;
        }

        switch (result.getViewType()) {
        case TASK_LIST:
            // Convert list to one with visual IDs only
            List<VisualTask> visualTaskList = getVisualIndexMapper()
                    .translateRawToVisual(result.getData());
            View view = new TaskListView(visualTaskList, this._lastCommand);
            this.getUserInterface().render(view);

            // Set header title
            if (this._lastCommand != null) {
                if (this._lastCommand.getInstruction() == Command.Instruction.SEARCH) {
                    String searchQuery = this._lastCommand.getParameter(Command.ParamName.SEARCH_QUERY);
                    this.getUserInterface().setHeaderTitle(String.format(
                            "Search results for \"%s\"",
                            searchQuery
                    ));
                } else {
                    this.getUserInterface().setHeaderTitle(
                            "All tasks"
                    );
                }
            }

            break;
        default:
            break;
        }

        // Display notification
        this.displayNotification(result);
    }

    @Override public void shutdown() {
        this.getUserInterface().cleanUp();
    }

    private void translateCommand(String commandString) {
        assert commandString != null;
        assert this._commandExecutionHandler != null;

        Command command = this.getCommandParser().parse(commandString);

        if (command.hasParameter(Command.ParamName.TASK_INDEX) ||
                command.hasParameter(Command.ParamName.TASK_INDEX_RANGES)) {
            VisualIndexMapper.getInstance().translateVisualToRaw(command);
        }

        // Catch unrecognised or invalid command
        if (command.getInstruction() == Command.Instruction.INVALID) {
            this.getUserInterface().showNotification(
                    command.getInvalidationMessage());
            return;
        } else if (command.getInstruction() == Command.Instruction.UNRECOGNISED) {
            this.getUserInterface().showNotification(
                    Message.UNRECOGNISED.toString());
            return;
        }

        // Set last command to this command
        this._lastCommand = command;

        // Schedule for displaying
        this._commandExecutionHandler.apply(command);
    }

    @Override public UserInterfaceSpec getUserInterface() {
        return UserInterface.getInstance();
    }

    @Override public CommandParserSpec getCommandParser() {
        return CommandParser.getInstance();
    }

    private static VisualIndexMapper getVisualIndexMapper() {
        return VisualIndexMapper.getInstance();
    }

    private void displayNotification(ExecutionResult result) {
        String message = Message.WELCOME.toString();

        if (this._lastCommand != null) {
            switch (this._lastCommand.getInstruction()) {
                case DISPLAY:
                    int taskCount = ((List<?>) result.getData()).size();
                    if (taskCount == 0) {
                        message = Message.DISPLAY_EMPTY.toString();
                    } else {
                        message = String.format(
                                Message.DISPLAY_NORMAL.toString(),
                                taskCount);
                    }
                    break;
                case ADD:
                    String taskName = this._lastCommand.getParameter(Command.ParamName.TASK_NAME);
                    message = String.format(Message.ADD_SUCCESS.toString(), taskName);
                    break;
                case EDIT:
                    message = Message.EDIT_SUCCESS.toString();
                    break;
                case DELETE:
                    if (result.hasErrorMessage()) {
                        message = result.getErrorMessage();
                    } else if (this._lastCommand.hasTrueValue(
                            Command.ParamName.TASK_UNIVERSALLY_QUANTIFIED)) {
                        message = Message.DELETE_ALL_SUCCESS.toString();
                    } else {
                        message = Message.DELETE_SUCCESS.toString();
                    }
                    break;
                case SEARCH:
                    int searchFound = ((List<?>) result.getData()).size();
                    String searchQuery = this._lastCommand.getParameter(Command.ParamName.SEARCH_QUERY);
                    if (searchFound == 0) {
                        message = String.format(Message.SEARCH_FAIL.toString(), searchQuery);
                    } else {
                        message = String.format(Message.SEARCH_SUCCESS.toString(),
                                searchFound,
                                searchQuery);
                    }
                    break;
                case UNDO:
                    if (result.hasErrorMessage()) {
                        message = result.getErrorMessage();
                    } else {
                        message = Message.UNDO_SUCCESS.toString();
                    }
                    break;
                case REDO:
                    if (result.hasErrorMessage()) {
                        message = result.getErrorMessage();
                    } else {
                        message = Message.REDO_SUCCESS.toString();
                    }
                    break;
                case MARK:
                    if (result.hasErrorMessage()) {
                        message = result.getErrorMessage();
                    } else if (this._lastCommand.hasTrueValue(
                            Command.ParamName.TASK_UNIVERSALLY_QUANTIFIED)) {
                        message = Message.MARK_ALL_SUCCESS.toString();
                    } else {
                        message = Message.MARK_SUCCESS.toString();
                    }
            }
        }

        this.getUserInterface().showNotification(message);
    }
}
```
###### ./main/java/logic/VisualIndexMapper.java
``` java
 */
public class VisualIndexMapper {

    /**
     * Singleton instance
     */
    private static VisualIndexMapper instance = new VisualIndexMapper();

    /**
     * Properties
     */
    private List<Task> _itemsList;

    public static VisualIndexMapper getInstance() {
        return instance;
    }

    private VisualIndexMapper() {
        this._itemsList = new ArrayList<>();
    }

    public void translateVisualToRaw(Command command) {
        assert !this._itemsList.isEmpty();

        // Parse a single task index
        if (command.hasParameter(Command.ParamName.TASK_INDEX)) {
            int visualIndex = command.getParameter(Command.ParamName.TASK_INDEX);
            Task item = this._itemsList.get(getArrayIndexFromVisualIndex(visualIndex));
            int rawIndex = item.getId();
            // FIXME: Might be null when the task is out of range
            command.setParameter(Command.ParamName.TASK_INDEX, rawIndex);
        }

        // Parse a list of visual ranges
        if (command.hasParameter(Command.ParamName.TASK_INDEX_RANGES)) {

            // TODO: Limit all the ranges to the bounds of the current task list
            List<Range> ranges = command.getParameter(Command.ParamName.TASK_INDEX_RANGES);

            // Enumerate all indices
            int[] indices = Range.enumerateRanges(ranges);

            // We are sure that all the visual indices are now valid
            // Proceed with translation
            ranges = Arrays.stream(indices).map(VisualIndexMapper::getArrayIndexFromVisualIndex)
                    .mapToObj(this._itemsList::get)
                    .map(Task::getId)
                    .map(Range::new)
                    .collect(Collectors.toList());
            Range.straightenRanges(ranges);
            command.setParameter(Command.ParamName.TASK_INDEX_RANGES, ranges);
        }
    }

    public List<VisualTask> translateRawToVisual(List<Task> rawList) {
        this._itemsList = rawList;
        return IntStream.range(0, rawList.size())
                .mapToObj(index -> new VisualTask(
                        getVisualIndexFromArrayIndex(index),
                        rawList.get(index)))
                .collect(Collectors.toList());
    }

    private static int getVisualIndexFromArrayIndex(int arrayIndex) {
        return arrayIndex + 1;
    }

    private static int getArrayIndexFromVisualIndex(int visualIndex) {
        return visualIndex - 1;
    }
}
```
###### ./main/java/shared/ApplicationContext.java
``` java
 */
public class ApplicationContext {

    /**
     * Singleton instance
     */
    private static ApplicationContext instance;

    /**
     * Properties
     */
    private Stage _primaryStage;
    private boolean _isTestingMode;

    /**
     * Private singleton constructor
     */
    private ApplicationContext() {
        this._isTestingMode = false;
    }

    /**
     * Returns the main application instance.
     *
     * @return
     */
    public static ApplicationContext mainContext() {
        if (instance == null) {
            instance = new ApplicationContext();
        }
        return instance;
    }

    /**
     * Returns the primary stage used by this JavaFX application.
     *
     * @return
     */
    public Stage getPrimaryStage() {
        assert (instance != null);
        assert (instance._primaryStage != null);
        return this._primaryStage;
    }

    /**
     * Manually determines the primary stage to be used by this application.
     *
     * @param primaryStage the stage to be used
     */
    public void setPrimaryStage(Stage primaryStage) {
        assert primaryStage != null;
        this._primaryStage = primaryStage;
    }

    /**
     * Returns whether the current application stack is running on test mode.
     * @return whether application is in test mode
     */
    public boolean isTestingMode() {
        return this._isTestingMode;
    }

    /**
     * Manually determines if testing mode is to be activated.
     * @param testing whether to activate testing mode
     */
    public void setTestingMode(boolean testing) {
        this._isTestingMode = testing;
    }
}
```
###### ./main/java/shared/Command.java
``` java
 */
public class Command {

    /**
     * Types
     */
    public enum Instruction {
        ADD, DISPLAY, MARK, EDIT, SEARCH, UNDO, REDO, DELETE,
        SCHEDULE, EXIT, UNRECOGNISED, INVALID;
    }

    public enum ParamType {
        STRING(String.class),
        DATE(CustomTime.class),
        PRIORITY(Task.Priority.class),
        BOOLEAN(Boolean.class),
        INTEGER(Integer.class),
        LIST(List.class);

        final Class<?> typeClass;

        ParamType(Class<?> tClass) {
            typeClass = tClass;
        }
    }

    public enum ParamName {
        TASK_NAME(ParamType.STRING),
        TASK_START(ParamType.DATE),
        TASK_END(ParamType.DATE),
        PRIORITY_VALUE(ParamType.PRIORITY),

        SEARCH_QUERY(ParamType.STRING),

        TASK_INDEX(ParamType.INTEGER),
        TASK_INDEX_RANGES(ParamType.LIST),
        TASK_UNIVERSALLY_QUANTIFIED(ParamType.BOOLEAN),

        TASK_DURATION(ParamType.INTEGER);

        public final ParamType type;

        ParamName(ParamType t) {
            type = t;
        }
    }

    /**
     * Properties
     */
    private Instruction _instruction;
    private LinkedHashMap<ParamName, Object> _parameters;

    /**
     * Constructs a command with the given instruction, index OR quantifier.
     *
     * @param instruction
     */
    public Command(Instruction instruction) {
        this._instruction = instruction;
        this._parameters = new LinkedHashMap<>();
    }

    public Instruction getInstruction() {
        return this._instruction;
    }

    public void setParameter(ParamName name, Object value) throws InvalidParameterException {
        if (!name.type.typeClass.isAssignableFrom(value.getClass())) {
            throw new InvalidParameterException(
                    String.format("A value of type %s cannot be assigned to parameter %s (%s)",
                            value.getClass().getCanonicalName(), name.name(),
                            name.type.typeClass.getCanonicalName()));
        }
        this._parameters.put(name, value);
    }

    @SuppressWarnings("unchecked") public <T> T getParameter(ParamName name) {
        try {
            return (T) this._parameters.get(name);
        } catch (ClassCastException e) {
            ExceptionHandler.handle(e);
            assert false; // We don't want this to happen
            return null;
        }
    }

    public boolean hasInstruction(Instruction instruction) {
        return this._instruction == instruction;
    }

    public boolean hasParameter(ParamName name) {
        return this._parameters.containsKey(name);
    }

    @Override public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(this._instruction);
        this._parameters.entrySet().forEach(entry -> {
            sb.append(" ").append(entry.getKey())
                    .append("=").append(entry.getValue());
        });
        return sb.toString();
    }

    public void removeParameter(ParamName taskName) {
        if (this._parameters.containsKey(taskName)) {
            this._parameters.remove(taskName);
        }
    }

    public int getParametersCount() {
        return this._parameters.keySet().size();
    }

    public static Command initialCommand() {
        Command command = new Command(Instruction.DISPLAY);
        command.setParameter(ParamName.TASK_UNIVERSALLY_QUANTIFIED, true);
        return command;
    }

    public boolean hasTrueValue(ParamName name) {
        try {
            return this.hasParameter(name) && (boolean) this.getParameter(name);
        } catch (ClassCastException e) {
            return false;
        }
    }

    /**
     * Special types of commands
     */
    public static Command invalidCommand(String message) {
        Command invalidCommand =  new Command(Instruction.INVALID);
        invalidCommand._invalidationMessage = message;
        return invalidCommand;
    }
    public static Command unrecognisedCommand() {
        return new Command(Instruction.UNRECOGNISED);
    }

    /**
     * Invalid commands handling
     */
    private String _invalidationMessage;
    public void setAsInvalid(String message) {
        this._instruction = Instruction.INVALID;
        this._invalidationMessage = message;
    }

    public String getInvalidationMessage() {
        assert this._instruction == Instruction.INVALID && this._invalidationMessage != null;
        return this._invalidationMessage;
    }
}
```
###### ./main/java/shared/CustomTime.java
``` java
 */
public class CustomTime implements Comparable<CustomTime> {
    /**
     * Constants
     */
    private static final char CHAR_SEPARATOR = 'T';
    private static final String TIME_FORMAT = "HH:mm";

    private static final DateTimeFormatter FORMATTER_DATE = DateTimeFormatter.ISO_DATE;
    private static final DateTimeFormatter FORMATTER_TIME = DateTimeFormatter.ofPattern(TIME_FORMAT);
    private static final ChronoUnit PRECISION_TIME_DEFAULT = ChronoUnit.MINUTES;
    private static final ChronoUnit PRECISION_TIME_ALL_NULL = ChronoUnit.FOREVER;

    /**
     * Properties
     */
    private final LocalDate _date;
    private final LocalTime _time;
    private final TemporalUnit _precision;

    public CustomTime(LocalDate date, LocalTime time, TemporalUnit precision) {
        this._date = date;
        this._time = time;
        if (time == null || time.getHour() == 0 && time.getMinute() == 0) {
            if (date == null) {
                this._precision = PRECISION_TIME_ALL_NULL;
            } else {
                this._precision = ChronoUnit.DAYS;
            }
        } else {
            this._precision = precision;
        }

    }

    public CustomTime(LocalDate date, LocalTime time) {
        this(date, time, PRECISION_TIME_DEFAULT);
    }

    public CustomTime(LocalDateTime dateTime) {
        this(dateTime.toLocalDate(), dateTime.toLocalTime());
    }

    public CustomTime(int year, Month month, int day, int hour, int minute) {
        this(LocalDate.of(year, month, day), LocalTime.of(hour, minute));
    }

    public CustomTime withPrecision(TemporalUnit unit) {
        return new CustomTime(this._date, this._time, unit);
    }

    public static CustomTime now() {
        return new CustomTime(LocalDate.now(), LocalTime.now());
    }

    public static CustomTime todayAt(LocalTime time) {
        return new CustomTime(LocalDate.now(), time);
    }

    public static CustomTime tomorrowAt(LocalTime time) {
        return new CustomTime(LocalDate.now().plusDays(1), time);
    }

    public CustomTime sameDayAt(LocalTime time) {
        return new CustomTime(this._date, time);
    }

    public CustomTime current(DayOfWeek dayOfWeek) {
        if (!this.hasDate()) {
            return null;
        }
        int thisDoW = this.getDate().getDayOfWeek().getValue();
        int destDoW = dayOfWeek.getValue();
        int offset = destDoW - thisDoW;
        if (offset < 0) {
            offset += 7;
        }
        return new CustomTime(this.getDate().plusDays(offset), this.getTime());
    }

    public CustomTime next(DayOfWeek dayOfWeek) {
        return new CustomTime(this.current(dayOfWeek).getDate().plusDays(7), null);
    }


    public LocalDate getDate() {
        return this._date;
    }

    public LocalTime getTime() {
        return this._time;
    }

    public TemporalUnit getPrecision() {
        return this._precision;
    }

    public boolean hasDate() {
        return this._date != null;
    }

    public boolean hasTime() {
        return this._time != null;
    }

    public boolean hasSameDate(CustomTime ct) { return this.getDate().equals(ct.getDate()); }

    @Override public String toString() {
        StringBuilder sb = new StringBuilder();
        if (this._date != null) {
            sb.append(FORMATTER_DATE.format(this._date));
        } else {
            sb.append("null");
        }
        sb.append(CHAR_SEPARATOR);
        if (this._time != null) {
            sb.append(FORMATTER_TIME.format(this._time));
        } else {
            sb.append("null");
        }
        return sb.toString();
    }

    public static CustomTime fromString(String customTimeString) {
        if (customTimeString == null || customTimeString.trim().isEmpty()) {
            return null;
        }
        String[] values = customTimeString.split(Character.toString(CHAR_SEPARATOR));
        LocalDate date;
        LocalTime time;
        if (values[0].equals("null")) {
            date = null;
        } else {
            date = LocalDate.parse(values[0], FORMATTER_DATE);
        }
        if (values[1].equals("null")) {
            time = null;
        } else {
            time = LocalTime.parse(values[1], FORMATTER_TIME);
        }
        return new CustomTime(date, time);
    }

    @Override
    public int compareTo(CustomTime time) {
        LocalDate thisDate = this.hasDate() ? this.getDate() : LocalDate.MAX;
        LocalDate otherDate = time.hasDate() ? time.getDate() : LocalDate.MAX;
        int comparison = thisDate.compareTo(otherDate);
        // If date differs return them straight away
        if (comparison != 0) {
            return comparison;
        }

        LocalTime thisTime = this.hasTime() ? this.getTime() : LocalTime.MAX;
        LocalTime otherTime = time.hasTime() ? time.getTime() : LocalTime.MAX;
        return thisTime.compareTo(otherTime);
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) return false;
        if (this == o) return true;
        if (o instanceof CustomTime) {
            CustomTime time = (CustomTime) o;
            if (this.hasDate() ^ time.hasDate()) return false;
            if (this.hasDate() && !this.getDate().equals(time.getDate())) {
                return false;
            }

            if (this.hasTime() ^ time.hasTime()) return false;
            return !(this.hasTime() && !this.getTime().equals(time.getTime()));

        } else if (o instanceof LocalDateTime) {
            CustomTime time = new CustomTime((LocalDateTime) o);
            return this.equals(time);
        } else {
            return false;
        }
    }

    public boolean isNullDate() {
        return !(this.hasDate() || this.hasTime());
    }

    public static int difference(CustomTime time1, CustomTime time2) {
        assert time1.hasDate() && time2.hasDate();
        LocalTime timeOf1 = time1.hasTime() ? time1.getTime() : LocalTime.of(0, 0);
        LocalTime timeOf2 = time2.hasTime() ? time2.getTime() : LocalTime.of(0, 0);

        LocalDateTime fullTime1 = time1.getDate().atTime(timeOf1);
        LocalDateTime fullTime2 = time2.getDate().atTime(timeOf2);
        return (int) Math.abs(fullTime1.until(fullTime2, ChronoUnit.MINUTES));
    }

    public CustomTime plusMinutes(long minutes) {
        LocalDateTime timeRepresentation = LocalDateTime.of(this.getDate(), this.getTime());
        LocalDateTime timeRepresentationAfterIncrement = timeRepresentation.plusMinutes(minutes);

        return new CustomTime(timeRepresentationAfterIncrement);
    }

    public CustomTime plusDays(long minutes) {
        LocalDateTime timeRepresentation = LocalDateTime.of(this.getDate(), this.getTime());
        LocalDateTime timeRepresentationAfterIncrement = timeRepresentation.plusMinutes(minutes);

        return new CustomTime(timeRepresentationAfterIncrement);
    }
}
```
###### ./main/java/shared/ExecutionResult.java
``` java
 */
public class ExecutionResult {
    /**
     * Properties
     */
    private ViewType _viewType;
    private Object _data;
    private boolean _isShutdownSignal;
    private String _errorMessage;

    public ExecutionResult(ViewType viewType, Object data, String error) {
        this._viewType = viewType;
        this._data = data;
        this._isShutdownSignal = false;
        this._errorMessage = error;
    }

    public ExecutionResult(ViewType viewType, Object data) {
        this(viewType, data, null);
    }

    public ViewType getViewType() {
        return this._viewType;
    }

    /**
     * Constructs an empty execution result (normally used for shutdown signal)
     */
    private ExecutionResult(boolean isShutdown) {
        this._viewType = null;
        this._data = null;
        this._isShutdownSignal = isShutdown;
    }

    public static ExecutionResult shutdownSignal() {
        return new ExecutionResult(true);
    }

    public boolean isShutdownSignal() {
        return this._isShutdownSignal;
    }

    @SuppressWarnings("unchecked") public <T> T getData() {
        try {
            return (T) this._data;
        } catch (ClassCastException e) {
            ExceptionHandler.handle(e);
            return null;
        }
    }

    public String getErrorMessage(){
        return this._errorMessage;
    }

    public void setErrorMessage(String errorMsg) {
        this._errorMessage = errorMsg;
    }

    public boolean hasErrorMessage() {
        return this._errorMessage != null;
    }
}
```
###### ./main/java/shared/Message.java
``` java
 */
public enum Message {

    WELCOME("Welcome to Your MOM!"),

    UNRECOGNISED("Oops! I don't really understand what you are saying"),

    DISPLAY_EMPTY("Add a new task by entering \"add <task name>\""),
    DISPLAY_NORMAL("Found %d tasks!"),

    ADD_SUCCESS("Added: %s"),
    EDIT_SUCCESS("Edited task to have new details! (undo-able)"),
    DELETE_SUCCESS("Deleted task! (undo-able)"),
    DELETE_ALL_SUCCESS("Deleted all tasks! (undo-able)"),
    DELETE_FAIL("No valid tasks in range to delete!"),

    SEARCH_FAIL("Found no task with the search query \"%s\""),
    SEARCH_SUCCESS("Found %d matches with the query \"%s\""),

    UNDO_SUCCESS("Reverted last command!"),
    UNDO_FAIL("No tasks to undo!"),
    REDO_SUCCESS("Redone last command!"),
    REDO_FAIL("No tasks to redo!"),

    MARK_SUCCESS("Marked task as completed! (undo-able)"),
    MARK_ALL_SUCCESS("Marked all tasks as completed! (undo-able)"),
    MARK_FAIL("No valid tasks in range to mark as complete!");

    private final String messageString;
    Message(String msg) {
        messageString = msg;
    }

    @Override public String toString() {
        return messageString;
    }
}
```
###### ./main/java/shared/Range.java
``` java
 */
public class Range implements Comparable<Range> {

    /**
     * Properties
     */
    private Integer _start;
    private Integer _end;

    /**
     * Constructs a range with the specified start and end (both inclusive).
     * @param start an integer value
     * @param end an integer value
     */
    public Range(int start, int end) {
        assert start <= end;
        this._start = start;
        this._end = end;
    }

    /**
     * Constructs a range that contains only one value.
     * @param singleIndex the value to contain
     */
    public Range(int singleIndex) {
        this._start = singleIndex;
    }

    public boolean hasEnd() {
        return this._end != null;
    }

    public boolean contains(int value) {
        if (!hasEnd()) { // Single index
            return this._start == value;
        }
        assert hasEnd();
        return value >= this._start && value <= this._end;
    }

    public boolean contains(Range another) {
        // If the other value is a single value, fall back
        // to the single value contains method
        if (!another.hasEnd()) {
            return this.contains(another.getStart());
        }

        // If the second value starts smaller than this then
        // it is definitely not contained inside
        if (another.getStart() < this.getStart()) {
            return false;
        }

        // When this doesn't have an end, the only case where
        // the second one is contained inside this, is where
        // the end value is exactly equal to the start value
        if (!this.hasEnd()) {
            return another.getEnd().equals(another.getStart());
        }

        // Compare the end points
        return another.getEnd() <= this.getEnd();
    }

    public Integer getStart() {
        return this._start;
    }

    public Integer getEnd() {
        return this._end;
    }

    public void setStart(int start) {
        this._start = start;
    }

    public void setEnd(int end) {
        this._end = end;
    }

    /**
     * For debugging.
     * @return
     */
    @Override public String toString() {
        if (!this.hasEnd()) {
            return this._start.toString();
        }
        return String.format("[%d,%d]", this._start, this._end);
    }

    @Override public boolean equals(Object o) {
        if (o == null) return false;
        if (this == o) return true;
        if (!(o instanceof Range)) return false;

        Range otherRange = (Range) o;
        // Unequal start
        if (!this.getStart().equals(otherRange.getStart())) {
            return false;
        }
        // Either one doesn't have (exclusive or)
        if (this.hasEnd() ^ otherRange.hasEnd()) {
            return false;
        }

        // Both doesn't have end
        if (!this.hasEnd()) {
            return true;
        }

        return this.getEnd().equals(otherRange.getEnd());
    }

    @Override public int compareTo(Range another) {
        return this.getStart().compareTo(another.getStart());
    }

    public static void straightenRanges(List<Range> rangeList) {
        Collections.sort(rangeList);
        Range previousRange = null;
        for (Iterator<Range> it = rangeList.iterator(); it.hasNext(); ) {
            Range thisRange = it.next();
            if (previousRange == null) {
                previousRange = thisRange;
                continue;
            }
            boolean didMerge = false;
            // Check for containment or overlap
            if (previousRange.contains(thisRange) || previousRange.contains(thisRange.getStart())) {
                // Does contain, merge the two!
                if (thisRange.hasEnd() && (!previousRange.hasEnd() || previousRange.hasEnd() &&
                        previousRange.getEnd() < thisRange.getEnd())) {
                    previousRange.setEnd(thisRange.getEnd());
                }
                it.remove();
                didMerge = true;
            }
            // Check for continuation of end [5, 6] + [6, 8]
            if (previousRange.hasEnd() && thisRange.getStart().equals(previousRange.getEnd() + 1)) {
                if (thisRange.hasEnd()) {
                    previousRange.setEnd(thisRange.getEnd());
                } else {
                    previousRange.setEnd(thisRange.getStart());
                }
                it.remove();
                didMerge = true;
            }
            // Check for continuation of start [5] [6] [7]
            if (!(previousRange.hasEnd() && thisRange.hasEnd()) &&
                    thisRange.getStart().equals(previousRange.getStart() + 1)) {
                previousRange.setEnd(thisRange.getStart());
                it.remove();
                didMerge = true;
            }

            if (!didMerge) {
                previousRange = thisRange;
            }
        }
    }

    public static int[] enumerateRanges(List<Range> ranges) {
        return ranges.stream().flatMapToInt(range -> {
            if (!range.hasEnd()) {
                return IntStream.of(range.getStart());
            } else {
                return IntStream.range(range.getStart(), range.getEnd() + 1);
            }
        }).sorted().toArray();
    }
}
```
###### ./main/java/shared/Resources.java
``` java
 */
public class Resources {
    /**
     * Constants
     */
    private static final String STRING_EXTENSION_TEMPLATES = ".fxml";
    private static final String STRING_EXTENSION_STYLESHEETS = ".css";
    private static final String STRING_EXTENSION_FONTS = ".ttf";

    private static final String STRING_PATH_TEMPLATES = "templates/";
    private static final String STRING_PATH_FONTS = "fonts/";
    private static final String STRING_PATH_STYLESHEETS = "stylesheets/";

    /**
     * Properties
     */
    private final ClassLoader _classLoader;

    /**
     * Singleton class implementation
     */
    private static Resources instance = new Resources();

    public static Resources sharedResources() {
        return instance;
    }

    private Resources() {
        this._classLoader = this.getClass().getClassLoader();
    }

    /**
     * Builds a JavaFX view from the specified FXML template.
     *
     * @param template
     *            the template name (without extension)
     *
     * @return null if template not found
     */
    public <T> T getComponent(String template) {
        try {
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(getTemplateUrl(template));
            return loader.load();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public <T, C> Pair<T, C> getComponentAndController(String template) {
        try {
            FXMLLoader loader = new FXMLLoader();
            URL templateUrl = getTemplateUrl(template);
            loader.setLocation(templateUrl);

            T component = loader.load();
            C controller = loader.getController();

            return new Pair<>(component, controller);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    private URL getTemplateUrl(String template) {
        String fullPath = String.format("%s%s%s", STRING_PATH_TEMPLATES, template, STRING_EXTENSION_TEMPLATES);
        URL resourceUrl = this._classLoader.getResource(fullPath);
        return resourceUrl;
    }

    public String getFontUrl(String font) {
        String fontPath = String.format("%s%s%s", STRING_PATH_FONTS, font, STRING_EXTENSION_FONTS);
        return this._classLoader.getResource(fontPath).toExternalForm();
    }

    public String getStylesheet(String stylesheet) {
        String cssPath = String.format("%s%s%s", STRING_PATH_STYLESHEETS, stylesheet, STRING_EXTENSION_STYLESHEETS);
        return this._classLoader.getResource(cssPath).toExternalForm();
    }

    public Image getImage(String imageName) {
        String imagePath = "images/" + imageName;
        String imageFullPath = this._classLoader.getResource(imagePath).toExternalForm();
        return new Image(imageFullPath);
    }

    public String getDataFrom(String dataFile) {
        InputStream stream = this._classLoader.getResourceAsStream("data/" + dataFile);
        StringWriter writer = new StringWriter();
        try {
            IOUtils.copy(stream, writer, StandardCharsets.UTF_8);
        } catch (IOException e) {
            ExceptionHandler.handle(e);
            return null;
        }
        return writer.toString();
    }
}
```
###### ./main/java/shared/StringUtils.java
``` java
 */
public class StringUtils {
    public static final char CHAR_QUOTES = '\"';

    // we don't want this class to be instantiated
    private StringUtils() {
    }

    public static boolean isSurroundedByQuotes(String string) {
        return string != null && string.length() >= 2 &&
                string.charAt(0) == CHAR_QUOTES && string.charAt(string.length() - 1) == CHAR_QUOTES;

    }

    public static String stripEndCharacters(String string) {
        if (string == null || string.length() < 2) {
            return "";
        }
        return string.substring(1, string.length() - 1);
    }
}
```
###### ./main/java/shared/ViewType.java
``` java
 */
public enum ViewType {
    TASK_LIST("TaskListView"),
    SINGLE_TASK("SingleTaskView");

    public final String template;

    ViewType(String temp) {
        template = temp;
    }
}
```
###### ./main/java/skeleton/StorageSpec.java
``` java
 */
public interface StorageSpec<T> {

    void initialise();

    int save(T item);

    T remove(int index);

    T get(int index);

    void undelete(int index);

    Set<Integer> getNonDeletedTasks();

    List<T> getAll();

    void shutdown();
}
```
###### ./main/java/skeleton/TranslationEngineSpec.java
``` java
 */
public interface TranslationEngineSpec {
    UserInterfaceSpec getUserInterface();

    CommandParserSpec getCommandParser();

    void setCommandExecutionHandler(Function<Command, ExecutionResult> handler);

    void initialise();

    void displayResult(ExecutionResult result);

    void shutdown();
}
```
###### ./main/java/ui/controller/CommandBarController.java
``` java
 */
public class CommandBarController {
    private static final String ID_COMMAND_INPUT = "command-input";
    private static final double PADDING_HORZ_COMMAND_INPUT = 12.0;
    private static final double PADDING_VERT_COMMAND_INPUT = 14.0;
    private static final int DELAY_HIGHLIGHT = 100;
    private static final String STYLE_CLASS_INSTRUCTION = "command__instruction";
    private static final String STYLE_CLASS_START_DATE = "command__start-date";
    private static final String STYLE_CLASS_END_DATE = "command__end-date";
    private static final String STYLE_CLASS_START_TIME = "command__start-time";
    private static final String STYLE_CLASS_END_TIME = "command__end-time";
    private static final String STYLE_CLASS_NORMAL = "command__normal-text";
    private static final String STYLE_CLASS_PRIORITY = "command__priority";

    @FXML private AnchorPane _commandBarContainer;

    private StyleClassedTextArea _inputField;
    private Function<String, Void> _inputSubmissionHandler;
    private Function<KeyEvent, Boolean> _interceptor;

    private ExecutorService _executor;

    // Regular expressions
    private String _instructionPattern;
    private String _startTimePattern;
    private String _endTimePattern;
    private String _priorityPattern;

    @FXML public void initialize() {
        this.initializeHighlighters();

        this.initializeComponents();

        this.initializeLayout();

        this.initializeHandlers();
    }

    /**
     * Sets up all the different highlighting patterns to be shown by the
     * command input field.
     */
    private void initializeHighlighters() {
        // Create the instruction highlight pattern
        CommandParser parser = CommandParser.getInstance();
        this._instructionPattern = parser.getInstructionPattern();
        this._startTimePattern   = parser.getStartTimePattern();
        this._endTimePattern     = parser.getEndTimePattern();
        this._priorityPattern    = parser.getPriorityPattern();
    }

    /**
     * Sets up all the event handlers that will be called upon when the command
     * input field is being interacted with.
     */
    private void initializeHandlers() {
        // Set handlers
        this._inputField.setOnKeyPressed(event -> {

            if (this._interceptor.apply(event)) {
                event.consume();
                return;
            }

            if (event.getCode() == KeyCode.ENTER) {

                assert _inputSubmissionHandler != null;

                // Throw event handler up to UserInterface
                String rawCommand = _inputField.getText();
                _inputSubmissionHandler.apply(rawCommand);

                // Clear the field
                _inputField.clear();
                event.consume();
            }
        });

        // Set highlighting
        EventStream<?> richChanges = this._inputField.richChanges();
        richChanges.successionEnds(Duration.ofMillis(DELAY_HIGHLIGHT)).supplyTask(this::computeHighlightingAsync)
                .awaitLatest(richChanges).filterMap(t -> {
                    if (t.isSuccess()) {
                        return Optional.of(t.get());
                    } else {
                        return Optional.empty();
                    }
                }).subscribe(this::applyHighlighting);
    }

    /**
     * Put the appropriate elements in place, visually.
     */
    private void initializeLayout() {
        String stylesheet = Resources.sharedResources().getStylesheet("CommandBar");
        this._inputField.getStylesheets().add(stylesheet);

        this._inputField.getStyleClass().add("command-input__field");
        this._inputField.setWrapText(false);

        // Arrange the input field correctly
        AnchorPane.setLeftAnchor(this._inputField, PADDING_HORZ_COMMAND_INPUT);
        AnchorPane.setRightAnchor(this._inputField, PADDING_HORZ_COMMAND_INPUT);
        AnchorPane.setTopAnchor(this._inputField, PADDING_VERT_COMMAND_INPUT);
        AnchorPane.setBottomAnchor(this._inputField, -5.0);
    }

    /**
     * Starts up or instantiates all the required components
     */
    private void initializeComponents() {
        this._executor = Executors.newSingleThreadExecutor();
        this._inputField = new StyleClassedTextArea();

        // Set an ID to the input field for easy reference
        this._inputField.setId(ID_COMMAND_INPUT);

        this._commandBarContainer.getChildren().add(this._inputField);
    }

    /**
     * TODO: Write JavaDoc
     *
     * @return
     */
    public void setInputSubmissionHandler(Function<String, Void> handler) {
        this._inputSubmissionHandler = handler;
    }

    public void setKeyInputInterceptor(Function<KeyEvent, Boolean> interceptor) {
        this._interceptor = interceptor;
    }

    private Task<StyleSpans<Collection<String>>> computeHighlightingAsync() {
        String text = this._inputField.getText();
        Task<StyleSpans<Collection<String>>> task = new Task<StyleSpans<Collection<String>>>() {
            @Override protected StyleSpans<Collection<String>> call() throws Exception {
                return computeHighlighting(text);
            }
        };
        try {
            this._executor.execute(task);
        } catch (RejectedExecutionException e) {
            // Do nothing
        }
        return task;
    }

    /**
     * TODO: Write JavaDoc
     * 
     * @param text text that is going to be processed as the highlight effect
     * @return
     */
    private StyleSpans<Collection<String>> computeHighlighting(String text) {
        int lastKeywordEnd = 0;
        StyleSpansBuilder<Collection<String>> spansBuilder = new StyleSpansBuilder<>();

        //-------------------------------------------------------------------
        // I. Instruction
        //-------------------------------------------------------------------
        Matcher instructionMatcher = RegexUtils.caseInsensitiveMatch(
                this._instructionPattern,
                text
        );
        // Must have a valid instruction before the rest gets highlighted
        if (instructionMatcher.find()) {
            // Fill in previous non-highlighted part
            spansBuilder.add(Collections.singleton(STYLE_CLASS_NORMAL),
                    instructionMatcher.start() - lastKeywordEnd);
            // Highlight instruction
            if (instructionMatcher.group(CommandParser.MATCHER_GROUP_INSTRUCTION) != null) {
                spansBuilder.add(
                        Collections.singleton(STYLE_CLASS_INSTRUCTION),
                        instructionMatcher.end() - instructionMatcher.start()
                );
            }
            // Update last keyword end
            lastKeywordEnd = instructionMatcher.end();
        } else {
            // Instruction not found, abort highlighting
            // Find in the rest
            spansBuilder.add(Collections.singleton(STYLE_CLASS_NORMAL), text.length() - lastKeywordEnd);
            return spansBuilder.create();
        }

        //-------------------------------------------------------------------
        // II. Start Time
        //-------------------------------------------------------------------
        Matcher startTimeMatcher = RegexUtils.caseInsensitiveMatch(
                this._startTimePattern,
                text
        );
        lastKeywordEnd = this.highlightTime(lastKeywordEnd, spansBuilder, startTimeMatcher, true);

        //-------------------------------------------------------------------
        // III. End Time
        //-------------------------------------------------------------------
        Matcher endTimeMatcher = RegexUtils.caseInsensitiveMatch(
                this._endTimePattern,
                text
        );
        lastKeywordEnd = this.highlightTime(lastKeywordEnd, spansBuilder, endTimeMatcher, false);

        //-------------------------------------------------------------------
        // IV. Priority
        //-------------------------------------------------------------------
        Matcher priorityMatcher = RegexUtils.caseInsensitiveMatch(
                this._priorityPattern,
                text
        );
        if (priorityMatcher.find()) {
            // Get group first
            int matcherStart = priorityMatcher.start(CommandParser.MATCHER_GROUP_PRIORITY);
            int matcherEnd = priorityMatcher.end(CommandParser.MATCHER_GROUP_PRIORITY);
            // Fill in previous non-highlighted part
            spansBuilder.add(Collections.singleton(STYLE_CLASS_NORMAL),
                    matcherStart - lastKeywordEnd);

            // Highlight priority
            spansBuilder.add(
                    Collections.singleton(STYLE_CLASS_PRIORITY),
                    matcherEnd - matcherStart
            );
            // Update last keyword end
            lastKeywordEnd = matcherEnd;
        }

        spansBuilder.add(Collections.singleton(STYLE_CLASS_NORMAL), text.length() - lastKeywordEnd);
        return spansBuilder.create();
    }

    private int highlightTime(int lastKeywordEnd, StyleSpansBuilder<Collection<String>> spansBuilder,
                              Matcher timeMatcher, boolean isStart) {
        String dateStyle = isStart ? STYLE_CLASS_START_DATE : STYLE_CLASS_END_DATE;
        String timeStyle = isStart ? STYLE_CLASS_START_TIME : STYLE_CLASS_END_TIME;

        if (timeMatcher.find(lastKeywordEnd)) {
            String matcherGroup = Arrays.asList(
                    CommandParser.MATCHER_GROUP_RELATIVE_TIME,
                    CommandParser.MATCHER_GROUP_DAY_OF_WEEK,
                    CommandParser.MATCHER_GROUP_DATE
            ).stream().filter(groupName -> timeMatcher.group(groupName) != null)
                    .findFirst().orElse(null);

            if (matcherGroup != null) {
                int matcherStart = timeMatcher.start(matcherGroup);
                int matcherEnd = timeMatcher.end(matcherGroup);

                // Fill in previous non-highlighted part
                spansBuilder.add(Collections.singleton(STYLE_CLASS_NORMAL),
                        matcherStart - lastKeywordEnd);

                // Highlight start date
                spansBuilder.add(
                        Collections.singleton(dateStyle),
                        matcherEnd - matcherStart
                );
                // Update last keyword end
                lastKeywordEnd = matcherEnd;

                if (timeMatcher.group(CommandParser.MATCHER_GROUP_TIME_OF_DAY) != null) {
                    int timeStart = timeMatcher.start(CommandParser.MATCHER_GROUP_TIME_OF_DAY);
                    int timeEnd = timeMatcher.end(CommandParser.MATCHER_GROUP_TIME_OF_DAY);
                    // Fill in previous non-highlighted part
                    spansBuilder.add(Collections.singleton(STYLE_CLASS_NORMAL),
                            timeStart - matcherEnd);
                    // Highlight start time
                    spansBuilder.add(
                            Collections.singleton(timeStyle),
                            timeEnd - timeStart
                    );

                    // Update last keyword end
                    lastKeywordEnd = timeEnd;
                }
            }
        }
        return lastKeywordEnd;
    }

    /**
     * TODO: Write JavaDoc
     * 
     * @param highlighting
     */
    private void applyHighlighting(StyleSpans<Collection<String>> highlighting) {
        this._inputField.setStyleSpans(0, highlighting);
    }

    /**
     * Performs the concluding actions before the application concludes.
     */
    public void cleanUp() {
        this._executor.shutdown();
    }

    public void requestFocus() {
        this._inputField.requestFocus();
    }
}
```
###### ./main/java/ui/controller/HeaderBarController.java
``` java
 */
public class HeaderBarController {

    @FXML private Label _titleLabel;

    @FXML public void initialize() {

    }

    public void setTitle(String title) {
        this._titleLabel.setText(title);
    }

}

```
###### ./main/java/ui/controller/NotificationToastController.java
``` java
 */
public class NotificationToastController {

    @FXML
    private AnchorPane _container;
    @FXML
    private Label _label;

    @FXML public void initialize() {

    }

    public void setNotification(String notification) {
        this._label.setText(notification);
    }
}
```
###### ./main/java/ui/UserInterface.java
``` java
 */
public class UserInterface implements UserInterfaceSpec {

    /**
     * Constants
     */
    private static final String[] SOURCES_FONT = {
            "Lato-Bold",
            "Lato-Regular",
            "Lato-Light"
    };
    private static final double SIZE_FONT_DEFAULT = 16.0;
    private static final String STYLE_CLASS_CONTAINER_MAIN = "sub-container";
    private static final double HEIGHT_MAIN_CONTAINER_MIN = 450.0;
    private static final double HEIGHT_MAIN_CONTAINER_MAX = 450.0;
    private static final double OFFSET_HIDE = 500.0;

    private static final int DURATION_ANIM_TRANSITION = 250;
    private static final int DURATION_ANIM_STOP = 5000;

    private static final Duration TIMELINE_INCOMING = Duration.millis(DURATION_ANIM_TRANSITION);
    private static final Duration TIMELINE_HANGING  = Duration.millis(DURATION_ANIM_TRANSITION + DURATION_ANIM_STOP);
    private static final Duration TIMELINE_OUTGOING = Duration.millis(
            DURATION_ANIM_TRANSITION + DURATION_ANIM_STOP + DURATION_ANIM_TRANSITION
    );

    private static final int INDEX_X = 0;
    private static final int INDEX_Y = 1;


    /**
     * Singleton instance
     */
    private static UserInterface instance;

    /**
     * Properties
     */
    private Function<String, Void> _commandInputHandler;
    private Stage _primaryStage;
    private BorderPane _rootView;
    private HeaderBarController _headerBarController;
    private CommandBarController _commandBarController;

    private StackPane _mainContainer;
    private AnchorPane _viewWrapper;
    private AnchorPane _notification;
    private NotificationToastController _notificationController;

    private UserInterface() {
    }

    public static UserInterface getInstance() {
        if (instance == null) {
            instance = new UserInterface();
        }
        return instance;
    }

    /**
     * This method will set up the GUI and its component. initialize() should only be called once when UserInterface is first
     * instantiated.
     */
    @Override
    public void initialize() {
        assert (ApplicationContext.mainContext().getPrimaryStage() != null);
        assert this._commandInputHandler != null;

        // Set primary stage
        this._primaryStage = ApplicationContext.mainContext().getPrimaryStage();
        try {
            this._primaryStage.initStyle(StageStyle.UNDECORATED);
        } catch (Exception e) {
            ExceptionHandler.handle(e);
        }

        this.initializeFonts();
        this.setRootView();

        this.registerHeaderBar();
        this.registerViewContainer();
        this.registerCommandBar();

        this.registerNotificationToast();
    }

    private void initializeFonts() {
        for (String font : SOURCES_FONT) {
            Font.loadFont(Resources.sharedResources().getFontUrl(font), SIZE_FONT_DEFAULT);
        }
    }

    private void setRootView() {
        this._rootView = Resources.sharedResources().getComponent("Window");
        Scene rootScene = new Scene(this._rootView);
        this._primaryStage.setScene(rootScene);
        this._primaryStage.setTitle("Your MOM");
        this._primaryStage.setResizable(false);
    }

    /**
     * This method will display the GUI.
     * show() should only be once called after the primary components of user interface, excluding the View,
     * has been constructed.
     */
    @Override
    public void show() {
        // Make sure stage and command input handler are both set
        assert (this._primaryStage != null);
        assert (this._commandInputHandler != null);

        // Initialize first view

        this._primaryStage.show();
    }

    /**
     * this method set the behavior for the commandInput Box when receiving input from the user
     *
     * @param onCommandInput the function that defines the actions taken after receiving input
     */
    @Override
    public void setOnCommandInputHandler(Function<String, Void> onCommandInput) {
        this._commandInputHandler = onCommandInput;
    }

    private void registerHeaderBar() {
        Pair<AnchorPane, HeaderBarController> headerBarMetadata =
                Resources.sharedResources().getComponentAndController("HeaderBar");

        AnchorPane headerBar = headerBarMetadata.getKey();
        this._headerBarController = headerBarMetadata.getValue();

        final double[] originalPosition = new double[2];
        final double[] offset = new double[2];

        // Header bar anchor pane will be used for moving
        headerBar.setOnMousePressed(event -> {
            Stage primaryStage = ApplicationContext.mainContext().getPrimaryStage();

            originalPosition[INDEX_X] = primaryStage.getX();
            originalPosition[INDEX_Y] = primaryStage.getY();

            offset[INDEX_X] = event.getScreenX();
            offset[INDEX_Y] = event.getScreenY();
        });
        headerBar.setOnMouseDragged(event -> {
            Stage primaryStage = ApplicationContext.mainContext().getPrimaryStage();
            double offsetX = event.getScreenX() - offset[INDEX_X];
            double offsetY = event.getScreenY() - offset[INDEX_Y];
            primaryStage.setX(originalPosition[INDEX_X] + offsetX);
            primaryStage.setY(originalPosition[INDEX_Y] + offsetY);
        });

        this._rootView.setTop(headerBar);
    }

    private void registerCommandBar() {
        assert (this._commandInputHandler != null);

        Pair<AnchorPane, CommandBarController> inputMetadata =
                Resources.sharedResources().getComponentAndController("CommandBar");

        assert inputMetadata != null;

        AnchorPane commandBar = inputMetadata.getKey();

        this._commandBarController = inputMetadata.getValue();
        this._commandBarController.setInputSubmissionHandler(
                rawCommand -> this._commandInputHandler.apply(rawCommand)
        );

        this._rootView.setBottom(commandBar);
    }

    private void registerViewContainer() {
        StackPane main = new StackPane();
        main.getStyleClass().add(STYLE_CLASS_CONTAINER_MAIN);
        main.setMinHeight(HEIGHT_MAIN_CONTAINER_MIN);
        main.setMaxHeight(HEIGHT_MAIN_CONTAINER_MAX);

        AnchorPane wrapper = new AnchorPane();
        wrapper.getStyleClass().add(STYLE_CLASS_CONTAINER_MAIN);
        wrapper.setMinHeight(HEIGHT_MAIN_CONTAINER_MIN);
        wrapper.setMaxHeight(HEIGHT_MAIN_CONTAINER_MAX);
        this._viewWrapper = wrapper;
        main.getChildren().add(this._viewWrapper);

        main.setAlignment(Pos.TOP_CENTER);

        this._mainContainer = main;
        this._rootView.setCenter(main);
    }

    private void registerNotificationToast() {
        assert this._mainContainer != null;

        Pair<AnchorPane, NotificationToastController> toastMetadata =
                Resources.sharedResources().getComponentAndController("NotificationToast");

        AnchorPane notificationContainer = toastMetadata.getKey();
        notificationContainer.setLayoutY(
                this._mainContainer.getHeight() - notificationContainer.getHeight() - 20.0
        );
        notificationContainer.toFront();
        notificationContainer.setTranslateY(-20.0);

        // Hide this outside of view for now
        notificationContainer.setTranslateX(-OFFSET_HIDE);

        this._notification = notificationContainer;
        this._notificationController = toastMetadata.getValue();
        this._mainContainer.getChildren().add(notificationContainer);
    }

    /***
     * The method will retrieve the display component which is constructed by the View Object and
     * attached it to the current display
     *
     * @param view View for the main Container, as of this version, view only has TaskListView object to display list of Task stored
     */
    @Override
    public void render(View view) {
        assert this._viewWrapper != null;
        assert view != null;

        // TODO: Account for similar controller, only update data
        this._viewWrapper.getChildren().clear();
        this._viewWrapper.getChildren().add(view.getComponent());
        this._commandBarController.setKeyInputInterceptor(view.getKeyInputInterceptor());
        this._commandBarController.requestFocus();
    }

    @Override
    public void cleanUp() {
        // Trickle down to controller
        this._commandBarController.cleanUp();
    }

    /***
     * This method will update the notification message following the given input parameter, and play
     * the animation to bring the notification bar on-screen for a given duration.
     *
     * @param notif message to be displayed in the notification bar
     */
    @Override
    public void showNotification(String notif) {
        assert this._notification != null;
        assert this._notificationController != null;

        // Set title first
        this._notificationController.setNotification(notif);

        final KeyValue initial = new KeyValue(
                this._notification.translateXProperty(),
                -OFFSET_HIDE
        );
        final KeyValue incoming = new KeyValue(
                this._notification.translateXProperty(),
                0,
                Interpolator.EASE_BOTH
        );
        final KeyValue outgoing = new KeyValue(
                this._notification.translateXProperty(),
                OFFSET_HIDE,
                Interpolator.EASE_BOTH
        );

        // Construct animation keyframes
        final KeyFrame initialFrame = new KeyFrame(Duration.ZERO, initial);
        final KeyFrame incomingFrame = new KeyFrame(TIMELINE_INCOMING, incoming);
        final KeyFrame hangingFrame = new KeyFrame(TIMELINE_HANGING, incoming);
        final KeyFrame outgoingFrame = new KeyFrame(TIMELINE_OUTGOING, outgoing);

        // Create the timeline and display
        final Timeline timeline = new Timeline(initialFrame, incomingFrame, hangingFrame, outgoingFrame);
        timeline.setCycleCount(1);
        timeline.play();
    }

    @Override
    public void setHeaderTitle(String title) {
        this._headerBarController.setTitle(title);
    }
}
```
###### ./main/java/ui/view/View.java
``` java
 */
public abstract class View {

    /**
     * Properties
     */
    private Object _data;
    private Command _lastCommand;
    private Node _component;

    public View(Object data, Command lastCommand) {
        this._data = data;
        if (lastCommand != null) {
            this._lastCommand = lastCommand;
        } else {
            this._lastCommand = Command.initialCommand();
        }
        this.buildContent();
    }

    protected <T> T getData() {
        try {
            return (T) this._data;
        } catch (ClassCastException e) {
            assert false; // Explode
            return null;
        }
    }

    protected Command getLastCommand() {
        return this._lastCommand;
    }

    /**
     * this method is called to register the view
     */
    protected abstract void buildContent();

    protected void setComponent(Node component) {
        component.setId("component--main");
        this._component = component;
    }

    public Node getComponent() {
        assert this._component != null;
        return this._component;
    }

    public void setData(Object data) {
        this._data = data;
    }

    public Function<KeyEvent, Boolean> getKeyInputInterceptor() {
        return (event -> false);
    }
}
```
###### ./main/resources/stylesheets/CommandBar.css
``` css
.command-bar__wrapper {
    -fx-background-color: transparent;
}

.command-bar__container {
    -fx-background-color: white;
    -fx-background-radius: 4px;
    -fx-border-radius: 4px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,.11), 8, 0.0, 0, 4);
}

.command-input__field {
    -fx-background-color: transparent;
    -fx-highlight-fill: #ddd;
}

.command-input__field .scroll-bar {
    -fx-opacity: 0;
    visibility: hidden;
}


/*-------------------------------------------------------------------------------------------------
 * COMMAND INPUT STYLES
 *-----------------------------------------------------------------------------------------------*/
.command-input__field {
    -fx-font-family: "Lato";
    -fx-font-size: 15px;
}

.command__instruction,
.command__start-date,
.command__end-date,
.command__start-time,
.command__end-time,
.command__priority {
    -fx-font-weight: bold;
}

.command__instruction {
    -fx-fill: #4198CF;
}

.command__start-date {
    -fx-fill: #00C779;
}

.command__start-time {
    -fx-fill: #108754;
}

.command__end-date {
    -fx-fill: #F6A500;
}

.command__end-time {
    -fx-fill: #E98205;
}

.command__priority {
    -fx-fill: #D926DC;
}
```
###### ./main/resources/stylesheets/HeaderBar.css
``` css
.header-bar {
    -fx-background-color: linear-gradient(#FFAD1F, #FFAE1C);
}

.header__text {
    -fx-text-fill: white;
    -fx-font-family: "Lato";
    -fx-font-weight: bold;
    -fx-font-size: 16px;
    -fx-alignment: baseline-left;
}
```
###### ./main/resources/stylesheets/NotificationToast.css
``` css
.toast__container {
    -fx-background-color: white;
    -fx-background-radius: 4px;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,.10), 8, 0.0, 0, 4);
}

.toast__label {
    -fx-font-family: "Lato";
    -fx-font-size: 14px;
    -fx-alignment: baseline-left;
    -fx-text-alignment: left;
}
```
###### ./main/resources/stylesheets/TaskList.css
``` css
.list--task {
    -fx-background-insets: 0;
    -fx-background-color: #f7f7f7;
}

.list-cell {
    -fx-padding: 0;
    -fx-background-color: #f7f7f7;
}

.list--task .scroll-bar {
    -fx-opacity: 0;
    visibility: hidden;
}

.list--task .scroll-bar .increment-arrow,
.list--task .scroll-bar .decrement-arrow,
.list--task .scroll-bar .increment-button,
.list--task .scroll-bar .decrement-button {
    -fx-padding:0;
}
```
###### ./main/resources/stylesheets/TaskListItem.css
``` css
.item__container {
    -fx-background-color: #f7f7f7;
}

.item__index {
    -fx-font-family: "Lato Light";
    -fx-font-weight: 300;
    -fx-font-size: 24px;
    -fx-text-fill: #828282;
}

.item__name {
    -fx-font-family: "Lato";
    -fx-font-weight: bold;
    -fx-text-fill: #525252;
    -fx-font-size: 14px;
}

.item__date {
    -fx-font-family: "Lato";
    -fx-font-size: 14px;
    -fx-text-fill: #787878;
}

.item__time {
    -fx-font-family: "Lato Light";
    -fx-font-weight: 300;
    -fx-text-fill: #2E2E2E;
    -fx-background-color: transparent;
}

.indicator--priority {
    visibility: hidden;
}

.indicator__text {
    -fx-font-family: "Lato";
    -fx-font-size: 12px;
    -fx-font-weight: bold;
}

.priority--high .indicator--priority {
    visibility: visible;
    -fx-fill: #FD6666;
}
.priority--medium .indicator--priority {
    visibility: visible;
    -fx-fill: #FDBA66;
}
.priority--low .indicator--priority {
    visibility: visible;
    -fx-fill: #73C3FF;
}

.list-cell.completed .item__name {
    -fx-font-weight: normal;
    -fx-text-fill: #ddd;
}

.list-cell.completed .item__time {
    -fx-text-fill: #B8E986;
}
```
###### ./main/resources/templates/CommandBar.fxml
``` fxml

<?import javafx.scene.layout.AnchorPane?>


<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="65.0" prefWidth="450.0" styleClass="command-bar__wrapper" stylesheets="@../stylesheets/CommandBar.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ui.controller.CommandBarController">
   <children>
      <AnchorPane layoutX="125.0" layoutY="-67.0" prefHeight="200.0" prefWidth="200.0" styleClass="command-bar__container" AnchorPane.bottomAnchor="10.0" AnchorPane.leftAnchor="10.0" AnchorPane.rightAnchor="10.0" AnchorPane.topAnchor="9.0" fx:id="_commandBarContainer" />
   </children>
</AnchorPane>
```
###### ./main/resources/templates/HeaderBar.fxml
``` fxml

<?import javafx.scene.control.Label?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.shape.Line?>

<AnchorPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="55.0" prefWidth="450.0" styleClass="header-bar" stylesheets="@../stylesheets/HeaderBar.css" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ui.controller.HeaderBarController">
   <children>
      <ImageView fitHeight="26.0" fitWidth="26.0" layoutX="15.0" layoutY="16.0" pickOnBounds="true" preserveRatio="true" AnchorPane.bottomAnchor="16.0" AnchorPane.leftAnchor="20.0" AnchorPane.rightAnchor="400.0" AnchorPane.topAnchor="15.0">
         <image>
            <Image url="@../images/checkbox_icon.png" />
         </image></ImageView>
      <Label fx:id="_titleLabel" layoutX="56.0" layoutY="19.0" styleClass="header__text" text="All tasks" AnchorPane.bottomAnchor="20.0" AnchorPane.leftAnchor="56.0" AnchorPane.topAnchor="18.0" />
      <Line endX="450.0" endY="55.0" startY="55.0" stroke="#e58816" />
   </children>
</AnchorPane>
```
###### ./main/resources/templates/Window.fxml
``` fxml

<?import javafx.scene.layout.BorderPane?>


<BorderPane maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="570.0" prefWidth="450.0" style="-fx-background-color: #F7F7F7;" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" />
```
###### ./test/java/helpers/CommandInputHelper.java
``` java
 */
public class CommandInputHelper {

    public static String constructAddCommand(String taskName) {
        return String.format("add %s", taskName);
    }

    public static String constructEditCommand(int visualId, String taskName) {
        return String.format("edit task number %d \"%s\"", visualId, taskName);
    }
}
```
###### ./test/java/helpers/IntegrationTestHelper.java
``` java
 */
public class IntegrationTestHelper {

    public static void startTestApplication(Stage primaryStage) {
        // Register the main stage and flag the application as testing
        ApplicationContext context = ApplicationContext.mainContext();
        context.setPrimaryStage(primaryStage);
        context.setTestingMode(true);

        // Start dispatcher
        DispatcherSpec dispatcher = Dispatcher.getInstance();
        dispatcher.initialise();
        dispatcher.start();
    }

    public static void shutdownTestApplication() {
        Dispatcher.getInstance().shutdown();
    }

    public static <T extends Control> T findComponent(String query) {
        try {
            return (T) ApplicationContext.mainContext().getPrimaryStage().getScene()
                    .lookup(query);
        } catch (ClassCastException|NullPointerException e) {
            return null;
        }
    }
}
```
###### ./test/java/logic/CommandParserTest.java
``` java
 */
public class CommandParserTest {

    private CommandParser _parser;

    @Before
    public void setUp() {
        this._parser = CommandParser.getInstance();
        this._parser.initialise();
    }

    @Test
    public void Command_parser_parses_simple_add_correctly() {
        Command command = this._parser.parse("add new task");
        assertThat(command.getInstruction(), is(Command.Instruction.ADD));
    }

    @Test
    public void Command_parser_parses_add_with_date_correctly() {
        Command command = this._parser.parse("add new task starting today 5pm to next Monday 1800");
        assertThat(command.getParameter(Command.ParamName.TASK_START),
                is(equalTo(CustomTime.todayAt(LocalTime.of(17, 0)))));
        assertThat(command.getParameter(Command.ParamName.TASK_END),
                is(equalTo(CustomTime.todayAt(LocalTime.of(18, 0)).current(DayOfWeek.MONDAY))));
    }

    @Test
    public void Command_parser_parses_add_with_exact_date_correctly() {
        Command command = this._parser.parse("add new task from 7th March's 0800 to Apr 27 2016");
        assertThat(command.getParameter(Command.ParamName.TASK_START),
                is(equalTo(new CustomTime(
                        LocalDate.of(2016, Month.MARCH, 7),
                        LocalTime.of(8, 0)
                ))));
        assertThat(command.getParameter(Command.ParamName.TASK_END),
                is(equalTo(new CustomTime(
                        LocalDate.of(2016, Month.APRIL, 27),
                        null
                ))));
    }

    @Test
    public void Command_parser_has_the_correct_task_name_without_quotes() {
        Command command = this._parser.parse("add new task starting today 5pm to next Monday 1800");
        assertThat(command.getParameter(Command.ParamName.TASK_NAME),
                is(equalTo("new task")));
    }

    @Test
    public void Command_parser_has_the_correct_task_name_with_quotes() {
        Command command = this._parser.parse("add \"new task starting today 5pm to next Monday 1800\"");
        assertThat(command.getParameter(Command.ParamName.TASK_NAME),
                is(equalTo("new task starting today 5pm to next Monday 1800")));
    }

    @Test
    public void Command_parser_parses_correctly_even_without_prepositions() {
        Command command = this._parser.parse("add new task today 7pm");
        assertThat(command.getParameter(Command.ParamName.TASK_END),
                is(equalTo(CustomTime.todayAt(LocalTime.of(19,0)))));
    }

    @Test
    public void Command_parser_regards_empty_add_phrases_as_invalid() {
        Command command = this._parser.parse("add");
        assertThat(command.getInstruction(), is(Command.Instruction.INVALID));
    }

    @Test
    public void Command_parser_regards_items_with_start_time_but_no_end_as_invalid() {
        Command command = this._parser.parse("add hello world starting tomorrow 7pm");
        assertThat(command.getInstruction(), is(Command.Instruction.INVALID));
    }

    @Test
    public void Command_parser_interprets_priority_correctly() {
        Command command = this._parser.parse("add hello world with high priority");
        assertThat(command.getParameter(Command.ParamName.PRIORITY_VALUE),
                is(equalTo(Task.Priority.HIGH)));
    }

    @Test
    public void Command_parser_parses_simple_edit_command_correctly() {
        Command command = this._parser.parse("edit task number 5 whatever from today until tomorrow");
        assertThat(command.getInstruction(), is(Command.Instruction.EDIT));
        assertThat(command.getParameter(Command.ParamName.TASK_NAME), is(equalTo("whatever")));
        assertThat(command.getParameter(Command.ParamName.TASK_START), is(equalTo(CustomTime.todayAt(null))));
        assertThat(command.getParameter(Command.ParamName.TASK_END), is(equalTo(CustomTime.tomorrowAt(null))));
    }

    @Test
    public void Command_parser_regards_edit_without_task_name_as_correct() {
        Command command = this._parser.parse("edit 3 starting today");
        assertThat(command.getParameter(Command.ParamName.TASK_START), is(equalTo(CustomTime.todayAt(null))));
        assertFalse(command.hasParameter(Command.ParamName.TASK_NAME));
    }

    @Test
    public void Command_parser_parses_edit_with_priority_correctly() {
        Command command = this._parser.parse("edit 3 with high priority");
        assertThat(command.getParameter(Command.ParamName.PRIORITY_VALUE),
                is(Task.Priority.HIGH));
    }

    @Test
    public void Command_parser_parses_delete_with_range_correctly() {
        String commandString = "delete 1-5, 3-7, 2-4, 10-19, 12, 21 to 23";
        Command command = this._parser.parse(commandString);
        List<Range> ranges = command.getParameter(Command.ParamName.TASK_INDEX_RANGES);

        assertThat(ranges, hasSize(3));
        assertThat(ranges, hasItems(
                new Range(1, 7),
                new Range(10, 19),
                new Range(21, 23)
        ));
    }

    @Test public void CommandParser_parses_simple_mark_correctly() {
        Command command = this._parser.parse("mark 5");
        assertThat(command.getInstruction(), is(equalTo(Command.Instruction.MARK)));
        List<Range> ranges = command.getParameter(Command.ParamName.TASK_INDEX_RANGES);
        assertThat(ranges, hasSize(1));
        assertThat(ranges, hasItem(new Range(5)));
    }

    @Test public void CommandParser_parses_simple_search_correctly() {
        Command command = this._parser.parse("search for this and that");
        assertThat(command.getInstruction(), is(Command.Instruction.SEARCH));
        assertThat(command.getParameter(Command.ParamName.SEARCH_QUERY),
                is(equalTo("this and that")));
    }

    @Test public void CommandParser_parses_complex_search_correctly() {
        Command command = this._parser.parse("find  \"for whatever\"");
        assertThat(command.getParameter(Command.ParamName.SEARCH_QUERY),
                is(equalTo("for whatever")));
    }

    @Test public void CommandParser_parses_universal_quantifier_correctly() {
        Arrays.asList("delete all tasks", "remove everything").forEach(commandString -> {
            Command command = this._parser.parse(commandString);
            assertTrue(command.hasTrueValue(Command.ParamName.TASK_UNIVERSALLY_QUANTIFIED));
            assertFalse(command.hasParameter(Command.ParamName.TASK_INDEX_RANGES));
        });
    }

    @Test public void CommandParser_parses_schedule_command_correctly() {
        Arrays.asList(
                "schedule task number 5 using 4 hours 30 minutes",
                "schedule task 5 4h30",
                "schedule 5 4.5"
        ).stream().map(this._parser::parse).forEach(command -> {
            assertThat(command.getInstruction(), is(Command.Instruction.SCHEDULE));
            assertThat(command.getParameter(Command.ParamName.TASK_INDEX), is(equalTo(5)));
            assertThat(command.getParameter(Command.ParamName.TASK_DURATION), is(equalTo(270)));
        });
    }
}
```
###### ./test/java/logic/VisualIndexMapperTest.java
``` java
 */
public class VisualIndexMapperTest {

    private static VisualIndexMapper getMapper() {
        return VisualIndexMapper.getInstance();
    }

    @Test
    public void Mapper_transforms_task_list_into_visual_list() {
        List<VisualTask> visualList = getMapper().translateRawToVisual(buildTaskList());
        // Index should start from 1
        int currentIndex = 1;
        for (VisualTask visualItem : visualList) {
            assertThat(visualItem.getVisualIndex(), is(equalTo(currentIndex++)));
        }
    }

    @Test
    public void Mapper_transforms_visual_command_into_raw_command() {
        getMapper().translateRawToVisual(buildTaskList());
        Command deleteCommand = new Command(Command.Instruction.DELETE);
        deleteCommand.setParameter(Command.ParamName.TASK_INDEX, 1);
        getMapper().translateVisualToRaw(deleteCommand);
        assertThat(deleteCommand.getParameter(Command.ParamName.TASK_INDEX), is(equalTo(51)));
    }

    @Test
    public void Mapper_transform_complex_task_list_correctly() {
        getMapper().translateRawToVisual(stubTasks(128, 47, 12, 13, 15, 67, 90, 20, 14, 68));
        Command deleteCommand = new Command(Command.Instruction.DELETE);
        deleteCommand.setParameter(Command.ParamName.TASK_INDEX_RANGES, Arrays.asList(
                new Range(2, 4),
                new Range(6),
                new Range(8, 10)
        ));

        getMapper().translateVisualToRaw(deleteCommand);
        List<Range> rawIdRanges = deleteCommand.getParameter(Command.ParamName.TASK_INDEX_RANGES);
        // [12,13,14] [67,68] [20]
        assertThat(rawIdRanges, hasSize(4));
        assertThat(rawIdRanges, hasItems(
                new Range(12, 14),
                new Range(20),
                new Range(47),
                new Range(67, 68)
        ));

    }

    private static List<Task> buildTaskList() {
        return IntStream.range(1, 5)
                .mapToObj(index -> new Task(index + 50, "Task " + index, "Lorem ipsum",
                        LocalDateTime.now(), LocalDateTime.now()))
                .collect(Collectors.toList());
    }

    private static Task stubTask(int index) {
        return new Task(index, "Task " + index, null, CustomTime.todayAt(null), CustomTime.tomorrowAt(null));
    }

    private static List<Task> stubTasks(int... taskId) {
        return IntStream.of(taskId).mapToObj(VisualIndexMapperTest::stubTask)
                .collect(Collectors.toList());
    }

}
```
###### ./test/java/shared/CustomTimeTest.java
``` java
 */
public class CustomTimeTest {

    @Test public void CustomTime_lets_user_instantiate_without_date() {
        CustomTime timeWithoutDate = new CustomTime(null, LocalTime.now());
        assertThat(timeWithoutDate.hasDate(), is(false));
    }

    @Test public void CustomTime_lets_user_instantiate_without_time() {
        CustomTime dateWithoutTime = new CustomTime(LocalDate.now(), null);
        assertThat(dateWithoutTime.hasTime(), is(false));
    }

    @Test public void CustomTime_toString_is_in_ISO_format_up_to_minute() {
        LocalDate nowDate = LocalDate.now();
        LocalTime nowTime = LocalTime.now();

        CustomTime timeObject = new CustomTime(nowDate, nowTime);
        assertThat(timeObject.toString(), is(equalTo(
                encodeTime(nowDate, nowTime)
        )));
    }

    @Test public void CustomTime_decodes_correctly_from_ISO_up_to_minute_string() {
        LocalDate nowDate = LocalDate.now();
        LocalTime nowTime = LocalTime.now().truncatedTo(ChronoUnit.MINUTES);
        DateTimeFormatter isoFormatterDate = DateTimeFormatter.ISO_DATE;
        DateTimeFormatter isoFormatterTime = DateTimeFormatter.ofPattern("HH:mm");
        String encodedTime = encodeTime(nowDate, nowTime);
        CustomTime time = CustomTime.fromString(encodedTime);

        assertThat(time.getDate(), is(equalTo(nowDate)));
        assertThat(time.getTime(), is(equalTo(nowTime)));
    }

    private static String encodeTime(LocalDate date, LocalTime time) {
        DateTimeFormatter isoFormatterDate = DateTimeFormatter.ISO_DATE;
        DateTimeFormatter isoFormatterTime = DateTimeFormatter.ofPattern("HH:mm");
        return String.format("%sT%s",
                isoFormatterDate.format(date),
                isoFormatterTime.format(time));
    }

    @Test public void CustomTime_gets_today_at_correctly() {
        LocalTime fivePm = LocalTime.of(17,0);
        CustomTime todayAt5 = CustomTime.todayAt(fivePm);
        assertThat(todayAt5.getDate(), is(equalTo(LocalDate.now())));
        assertThat(todayAt5.getTime(), is(equalTo(fivePm)));
    }

    @Test public void CustomTime_gets_tomorrow_at_correctly() {
        LocalTime fivePm = LocalTime.of(17,0);
        CustomTime tomorrowAt5 = CustomTime.tomorrowAt(fivePm);
        assertThat(tomorrowAt5.getDate(), is(equalTo(LocalDate.now().plusDays(1))));
        assertThat(tomorrowAt5.getTime(), is(equalTo(fivePm)));
    }

    @Test public void CustomTime_gets_same_day_at_correctly() {
        CustomTime time = CustomTime.now();
        CustomTime newTime = time.sameDayAt(LocalTime.of(16,0));
        assertThat(newTime.getDate(), is(equalTo(time.getDate())));
        assertThat(newTime.getTime(), is(equalTo(LocalTime.of(16, 0))));
    }

    @Test public void CustomTime_with_both_date_and_time_compares_normally() {
        LocalDateTime reference1 = LocalDateTime.now();
        LocalDateTime reference2 = reference1.plusHours(45);

        CustomTime time1 = new CustomTime(reference1);
        CustomTime time2 = new CustomTime(reference2);
        assertThat(time1.compareTo(time2), is(equalTo(reference1.compareTo(reference2))));
    }

    @Test public void CustomTime_with_null_date_is_greater_than_specified_date() {
        CustomTime specificDay = new CustomTime(LocalDate.now(), null);
        CustomTime floatingDay = new CustomTime(null, null);
        assertThat(specificDay.compareTo(floatingDay) < 0, is(true));
    }

    @Test public void CustomTime_with_null_time_is_greater_than_specified_time() {
        CustomTime specificTime = new CustomTime(LocalDateTime.now());
        CustomTime floatingTime = new CustomTime(LocalDate.now(), null);
        assertThat(specificTime.compareTo(floatingTime) < 0, is(true));
    }

    @Test public void CustomTime_calculates_correct_time_difference() {
        CustomTime time1 = CustomTime.todayAt(LocalTime.of(5, 30));
        CustomTime time2 = CustomTime.todayAt(LocalTime.of(7, 0));
        assertThat(CustomTime.difference(time1, time2),
                is(equalTo(90)));
    }

    @Test public void CustomTime_calculates_absolute_difference() {
        CustomTime time1 = CustomTime.todayAt(LocalTime.of(5, 30));
        CustomTime time2 = CustomTime.todayAt(LocalTime.of(7, 0));
        assertThat(CustomTime.difference(time2, time1),
                is(equalTo(90)));
    }

    @Test public void CustomTime_with_both_null_date_time_return_equal_time() {
        CustomTime nullTime = new CustomTime(null,null);
        CustomTime otherNullTime = new CustomTime(null,null);

        assertThat(nullTime.compareTo(otherNullTime) == 0, is(true));
    }

    @Test public void CustomTime_with_null_date_time_always_greater_than_other_date() {
        CustomTime nullTime = new CustomTime(null,null);
        CustomTime specificDayTime = new CustomTime(LocalDateTime.now());
        CustomTime specificDay = new CustomTime(LocalDate.now(),null);
        CustomTime specificTime = new CustomTime(null,LocalTime.now());

        assertThat(nullTime.compareTo(specificDayTime) > 0, is(true));
        assertThat(nullTime.compareTo(specificDay) > 0, is(true));
        assertThat(nullTime.compareTo(specificTime) > 0, is(true));
    }
}
```
###### ./test/java/shared/RangeTest.java
``` java
 */
public class RangeTest {

    @Test
    public void Range_of_single_index_has_only_start_value() {
        Range range = new Range(6);
        assertFalse(range.hasEnd());
    }

    @Test
    public void Range_is_inclusive() {
        Range range = new Range(5, 10);
        assertTrue(range.contains(5));
        assertTrue(range.contains(10));
    }

    @Test
    public void Range_of_only_start_does_not_contain_anything_after() {
        Range range = new Range(8);
        assertFalse(range.contains(9));
    }

    @Test
    public void Range_contains_a_value_inbetween() {
        Range range = new Range(-1, 9);
        assertTrue(range.contains(5));
    }

    @Test
    public void Range_does_not_contain_outside_values() {
        Range range = new Range(-5, 9);
        assertFalse(range.contains(-6));
        assertFalse(range.contains(10));
    }

    @Test
    public void Ranges_with_same_bounds_are_equal() {
        Range range1 = new Range(1, 6);
        Range range2 = new Range(1, 6);
        assertThat(range1, is(equalTo(range2)));
    }

    @Test
    public void Ranges_with_same_start_but_one_null_end_are_not_equal() {
        Range range1 = new Range(1, 6);
        Range range2 = new Range(1);
        assertThat(range1, is(not(equalTo(range2))));
    }

    @Test
    public void Ranges_with_same_start_but_different_ends_are_not_equal() {
        Range range1 = new Range(1, 5);
        Range range2 = new Range(1, 6);
        assertThat(range1, is(not(equalTo(range2))));
    }

    @Test
    public void Overlapping_ranges_are_not_equal() {
        Range range1 = new Range(1, 5);
        Range range2 = new Range(2, 5);
        assertThat(range1, is(not(equalTo(range2))));
    }

    @Test
    public void A_larger_range_contains_a_smaller_range() {
        Range larger = new Range(1, 7);
        Range smaller = new Range(3, 5);
        assertTrue(larger.contains(smaller));
    }

    @Test
    public void A_single_index_range_contains_a_range_with_same_start_end_values() {
        Range index = new Range(5);
        Range range = new Range(5, 5);
        assertTrue(index.contains(range));
    }

    @Test
    public void A_smaller_range_does_not_contain_a_larger_range() {
        Range smaller = new Range(1, 4);
        Range larger = new Range(2, 5);
        assertFalse(smaller.contains(larger));
    }

    @Test
    public void Two_non_overlapping_ranges_do_not_contain_each_other() {
        Range range1 = new Range(1, 4);
        Range range2 = new Range(5, 6);
        assertFalse(range1.contains(range2));
        assertFalse(range2.contains(range1));
    }

    @Test
    public void A_range_should_contain_itself() {
        Range range = new Range(2, 6);
        assertTrue(range.contains(range));
    }

    @Test(expected = AssertionError.class)
    public void A_range_cannot_end_earlier_than_it_starts() {
        Range range = new Range(10, 1);
    }

    @Test
    public void Range_with_single_values_merge_when_continuous() {
        List<Range> ranges = new ArrayList<>(Arrays.asList(
                new Range(5),
                new Range(6),
                new Range(7),
                new Range(8)
        ));
        Range.straightenRanges(ranges);
        assertThat(ranges, hasSize(1));
        assertThat(ranges, hasItem(new Range(5, 8)));
    }
}
```
###### ./test/java/shared/RegexUtilsTest.java
``` java
 */
public class RegexUtilsTest {

    @Test
    public void RegexUtils_constructs_correct_case_insensitive_matcher() {
        String pattern = "hello\\s+(?<MATCH>world)";
        Matcher matcher = RegexUtils.caseInsensitiveMatch(pattern, "hello WoRlD");
        assertTrue(matcher.find());
    }

    @Test
    public void RegexUtils_constructs_correct_choice_regex() {
        Matcher matcher = RegexUtils.caseInsensitiveMatch(
                RegexUtils.choice("one", "two", "three"),
                "I want two eggs"
        );
        assertTrue(matcher.find());
    }

    @Test
    public void RegexUtils_constructs_correct_named_choice_regex() {
        Matcher matcher = RegexUtils.caseInsensitiveMatch(
                RegexUtils.namedChoice("NUMBER", "one", "two", "three"),
                "Three bears"
        );
        assertTrue(matcher.find());
        assertThat(matcher.group("NUMBER").toLowerCase(), is(equalTo("three")));
    }
}
```
