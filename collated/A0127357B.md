# A0127357B
###### ./main/java/shared/Task.java
``` java
 */
public class Task implements Comparable<Task> {

    /**
     * Constants
     */
    private static final char DELIMITER_CSV = ',';

    /**
     * Properties
     */
    private Integer _id;
    private String _taskName;
    private String _description;
    private CustomTime _startTime;
    private CustomTime _endTime;
    private final LocalDateTime _creationTime;
    private Boolean _isCompleted;
    private Priority _priority;
    private boolean _isDeleted;

    /**
     * Priority types
     *
     * @author Huiyie
     *
     */
    public enum Priority {
        LOW(0), NULL(1), MEDIUM(2), HIGH(3);

        private final int PRIORITY_VALUE;

        Priority(int priority) {
            this.PRIORITY_VALUE = priority;
        }

        public int getPriorityValue() {
            return this.PRIORITY_VALUE;
        }

        @Override public String toString() {
            return Integer.toString(PRIORITY_VALUE);
        }
    };

    /**
     * TODO: Write JavaDoc
     *
     * @param id
     * @param taskName
     * @param description
     * @param startTime
     * @param endTime
     */
    public Task(Integer id, String taskName, String description, CustomTime startTime, CustomTime endTime) {
        this(id, taskName, description, LocalDateTime.now(), startTime, endTime, false, Priority.NULL, false);
    }

    public Task(Integer id, String taskName, String description, LocalDateTime startTime, LocalDateTime endTime) {
        this(id, taskName, description, new CustomTime(startTime), new CustomTime(endTime));
    }

    // copy ctor, used to construct an identical copy in the clone method
    private Task(Task o) {
        this(o._id,
                o._taskName,
                o._description,
                o._creationTime,
                o._startTime,
                o._endTime,
                o._isCompleted,
                o._priority,
                o._isDeleted);
    }

    private Task(Integer id, String taskName, String description, LocalDateTime creationTime, CustomTime startTime,
            CustomTime endTime, boolean isCompleted, Priority priority, boolean isDeleted) {
        this._id = id;
        this._taskName = taskName;
        this._description = description;
        this._creationTime = creationTime;
        this._startTime = startTime;
        this._endTime = endTime;
        this._isCompleted = isCompleted;
        this._priority = priority;
        this._isDeleted = isDeleted;
    }

    @Override public Task clone() {
        return new Task(this);
    }

    // ----------------------------------------------------------------------------------------
    //
    // Methods for encoding Task to String
    //
    // ----------------------------------------------------------------------------------------

    public String encodeTaskToString() {
        return String.join(Character.toString(DELIMITER_CSV), this.taskAttributesToStringArray());
    }

    private Object[] attributesToSerialize() {
        return new Object[] { this._id, this._taskName, this._description, this._creationTime, this._startTime,
                this._endTime, this._isCompleted, this._priority };
    }

    private String sanitise(Object attribute) {
        // Empty or null objects are treated similarly
        if (attribute == null) {
            return "";
        }

        // Convert the object to String
        String sanitised = attribute.toString();

        // Detect presence of commas
        if (sanitised.contains(Character.toString(DELIMITER_CSV))) {
            // Sanitise backslashes
            sanitised = sanitised.replace("\\", "\\\\");
            // Sanitise quotes
            sanitised = sanitised.replace("\"", "\\\"");
            // Has space, wrap around quotes
            sanitised = String.format("\"%s\"", sanitised);
        }

        return sanitised;
    }

    public String[] taskAttributesToStringArray() {
        // Sanitise data
        return Arrays.stream(this.attributesToSerialize()).map(this::sanitise).collect(Collectors.toList())
                .toArray(new String[] {});
    }

    public static Task decodeTaskFromString(String line) {
        // Begin dynamic decoding
        List<String> taskValues = new ArrayList<>();

        int begin = 0;
        boolean isDecodingSpecialValue = false;
        for (int i = 0; i < line.length(); i++) {
            if (i == begin && line.charAt(i) == '"') {
                isDecodingSpecialValue = true;
                continue;
            }
            if (line.charAt(i) == '"' && isDecodingSpecialValue) {
                // Fake quotes
                if (i > 0 && line.charAt(i - 1) == '\\') {
                    continue;
                }

                String specialValue = line.substring(begin + 1, i);
                specialValue = specialValue.replace("\\\"", "\"");
                specialValue = specialValue.replace("\\\\", "\\");
                taskValues.add(specialValue);

                begin = i + 2;
                i += 1;
                isDecodingSpecialValue = false;
                continue;
            }
            if (line.charAt(i) == DELIMITER_CSV && !isDecodingSpecialValue) {
                String value = line.substring(begin, i);
                taskValues.add(value);
                begin = i + 1;
            }
        }
        // Account for last leftover value
        if (begin < line.length() && begin >= 0) {
            taskValues.add(line.substring(begin));
        }

        // Begin decoding values
        int id = Integer.parseInt(taskValues.get(0));
        String taskName = taskValues.get(1);
        String description = taskValues.get(2);
        LocalDateTime creationTime = LocalDateTime.parse(taskValues.get(3));
        CustomTime startTime = CustomTime.fromString(taskValues.get(4).trim());
        CustomTime endTime   = CustomTime.fromString(taskValues.get(5).trim());

        boolean isCompleted = taskValues.get(6).trim().toLowerCase().equals("true");

        final Priority[] priority = new Priority[] { Priority.LOW };
        int priorityValue = Integer.parseInt(taskValues.get(7));
        Arrays.stream(Priority.values()).filter(p -> p.getPriorityValue() == priorityValue).findFirst()
                .ifPresent(p -> priority[0] = p);

        return new Task(id, taskName, description, creationTime, startTime, endTime, isCompleted, priority[0], false);
    }

    @Override public int compareTo(Task o) {
        return this.getId().compareTo(o.getId());
    }

    @Override public boolean equals(Object o) {
        if (o == null)
            return false;
        if (this == o)
            return true;
        if (!(o instanceof Task))
            return false;

        Task task = (Task) o;
        return this.getId().equals(task.getId());
    }

    @Override public int hashCode() {
        return this.getId().hashCode();
    }

    /**
     * Getters
     */
    public Integer getId() {
        return this._id;
    }

    public String getTaskName() {
        return this._taskName;
    }

    public String getDescription() {
        return this._description;
    }

    public LocalDateTime getCreationTime() {
        return this._creationTime;
    }

    public CustomTime getStartTime() {
        return this._startTime;
    }

    public CustomTime getEndTime() {
        return this._endTime;
    }

    public Priority getPriority() {
        return this._priority;
    }

    public boolean isCompleted() {
        return this._isCompleted;
    }

    public boolean isDeleted() {
        return this._isDeleted;
    }

    /**
     * Setters
     */
    public void setDeletedStatus(boolean isDeleted) {
        this._isDeleted = isDeleted;
    }

    public void setId(Integer id) {
        this._id = id;
    }

    public void setTaskName(String taskname) {
        this._taskName = taskname;
    }

    public void setDescription(String description) {
        this._description = description;
    }

    public void setStartTime(CustomTime start) {
        this._startTime = start;
    }

    public void setEndTime(CustomTime end) {
        this._endTime = end;
    }

    public void setPriority(Priority priority) {
        this._priority = priority;
    }

    public void setCompleted(boolean isCompleted) {
        this._isCompleted = isCompleted;
    }
}
```
###### ./main/java/storage/DiskIO.java
``` java
 *
 */
public class DiskIO {

    private static final DiskIO instance = new DiskIO();

    public static DiskIO getInstance() {
        return instance;
    }

    private String _fileName;
    private UserPreferences _userPreferences;

    private DiskIO() {
        this._userPreferences = UserPreferences.getInstance();
        processUserPreferencesFile();
        this.createDirectory();
    }

    public void processUserPreferencesFile() {
        this._userPreferences.createOrReadPreferencesFile();
        this._fileName = this._userPreferences.getTodoDataPath();
    }

    public String getFileName() {
        return this._fileName;
    }

    public void setFileName(String fileName) {
        this._fileName = fileName;
        createDirectory();
    }

    public void createDirectory() {
        // Try to create directory
        File folder = new File(this._fileName).getParentFile();
        folder.mkdirs();
    }

    public ArrayList<String> read() {
        // Create file if it does not already exist
        this.checkFileExists();
        ArrayList<String> taskStrings = new ArrayList<String>();

        try {
            BufferedReader reader = new BufferedReader(new FileReader(this._fileName));

            String currLine;
            while ((currLine = reader.readLine()) != null) {
                taskStrings.add(currLine);
            }
            reader.close();
        } catch (IOException e) {
            ExceptionHandler.handle(e);
        }
        return taskStrings;
    }

    public List<String> write(List<String> taskStrings) {
        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(this._fileName));
            for (String taskString : taskStrings) {
                writer.write(taskString);
                writer.newLine();
            }
            writer.close();
        } catch (IOException e) {
            ExceptionHandler.handle(e);
        }
        return taskStrings;
    }

    private File checkFileExists() {
        File file = new File(this._fileName);
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                ExceptionHandler.handle(e);
            }
        }
        return file;
    }
}
```
###### ./main/java/storage/Storage.java
``` java
 */
public class Storage extends TimerTask implements StorageSpec<Task> {

    /**
     * Constants
     */
    private static final int INDEX_TASK_INITIAL = 1;
    private static final int SAVE_FIRST_DELAY = 5000;
    private static final int SAVE_DELAY = 5000;

    /**
     * Singleton Implementation
     */
    private static Storage instance = new Storage();
    public static Storage getInstance() {
        return instance;
    }

    /**
     * Properties
     */
    private TreeMap<Integer, Task> _taskData;
    private boolean _isDirty;
    private Timer _autosaveTimer;

    /**
     * Constructs a new Storage instance.
     * the singleton constructor is made protected instead of private to enable dependency injection of Storage in tests
     * of other components
     */
    protected Storage() {
        // Instantiates storage
        this._taskData = new TreeMap<>();
        this._isDirty = false;
    }

    @Override
    public void run() {
        if (!this._isDirty) return;
        this.writeToDisk();
    }

    @Override
    public void initialise() {
        this.readFromDisk();

        this._autosaveTimer = new Timer();
        this._autosaveTimer.scheduleAtFixedRate(this, SAVE_FIRST_DELAY, SAVE_DELAY);
    }


    // ----------------------------------------------------------------------------------------
    //
    // I. Save Method
    //
    // ----------------------------------------------------------------------------------------

    /**
     * Saves a Task object to TreeMap
     *
     * @param task
     *            the Task to put into TreeMap
     * @return the ID of the added Task
     */
    @Override public int save(Task task) {
        // TODO: Check for potential time clashes
        boolean isNewTask = (task.getId() == null);

        // Find a new ID for tasks that does not exist inside the storage
        if (isNewTask) {
            int newIndex = INDEX_TASK_INITIAL;

            if (!this._taskData.isEmpty()) {
                // Use last index increment
                newIndex = this._taskData.lastKey() + 1;
            }

            task.setId(newIndex);
        }

        // Put the task
        this._taskData.put(task.getId(), task);
        this._isDirty = true;

        return task.getId();
    }

    private void writeToDisk() {
        List<Task> allTask = this.getAll();

        // Keep internal index serial
        List<String> tasksToWrite = IntStream.range(0, allTask.size()).mapToObj(index -> {
            Task task = allTask.get(index).clone();
            task.setId(index + 1);
            return task;
        }).map(Task::encodeTaskToString).collect(Collectors.toList());
        this.getDiskIO().write(tasksToWrite);

        this._isDirty = false;
    }

    // ----------------------------------------------------------------------------------------
    //
    // II. Get Method
    //
    // ----------------------------------------------------------------------------------------

    /**
     * Returns the Task to which the specified index is mapped
     *
     * @param index
     *            the index whose associated Task is to be returned
     * @return the Task to which the specified index is mapped
     */
    @Override public Task get(int index) {
        // check if TreeMap contains the key that is queried
        // check if the Task entry has already been deleted
        if (!this._taskData.containsKey(index) || this._taskData.get(index).isDeleted()) {
            try {
                throw new PrimaryKeyNotFoundException(index);
            } catch (PrimaryKeyNotFoundException e) {
                ExceptionHandler.handle(e);
            }
            return null;
        }

        // key exists, retrieve Task corresponding to key
        return this._taskData.get(index);
    }

    // ----------------------------------------------------------------------------------------
    //
    // III. GetAll Method
    //
    // ----------------------------------------------------------------------------------------

    /**
     * Returns a filtered list of Tasks that match the specified TaskDescriptor
     * Returns the full (unfiltered) list of Tasks when no TaskDescriptor is
     * specified
     *
     * @return results which is a list of filtered Tasks that matches
     *         TaskDescriptor if one is specified, else results is the full list
     *         of Tasks stored in TreeMap
     */
    @Override public List<Task> getAll() {
        return this._taskData.values().stream()
                .filter(task -> !task.isDeleted())
                .collect(Collectors.toList());
    }

    // ----------------------------------------------------------------------------------------
    //
    // IV. Remove Method
    //
    // ----------------------------------------------------------------------------------------
    /**
     * Removes the mapping for this index from TreeMap if present
     *
     * @param id
     *            index for which mapping should be removed
     * @return the previous Task associated with id, or null if there was no
     *         mapping for id
     */
    @Override public Task remove(int id) {
        if (!this._taskData.containsKey(id)) {
            try {
                throw new PrimaryKeyNotFoundException(id);
            } catch (PrimaryKeyNotFoundException e) {
                // TODO Auto-generated catch block
                ExceptionHandler.handle(e);
            }
            return null;
        }
        this._taskData.get(id).setDeletedStatus(true);
        this._isDirty = true;
        return this._taskData.get(id);
    }

    @Override public void undelete(int id) {
        if (!(this._taskData.containsKey(id) && this._taskData.get(id).isDeleted())) {
            try {
                throw new PrimaryKeyNotFoundException(id);
            } catch (PrimaryKeyNotFoundException e) {
                ExceptionHandler.handle(e);
            }
        }
        this._taskData.get(id).setDeletedStatus(false);
        this._isDirty = true;
    }

    /**
     * Clears all the Tasks from storage.
     */
    public void removeAll() {
        this._taskData.clear();
        this._isDirty = true;
    }

    @Override
    public Set<Integer> getNonDeletedTasks() {
        return this._taskData.keySet()
                .stream()
                .filter(id -> !this._taskData.get(id).isDeleted())
                .collect(Collectors.toSet());
    }

    // ----------------------------------------------------------------------------------------
    //
    // V. Search by Time Range Methods
    //
    // ----------------------------------------------------------------------------------------

    /**
     * Search for all Tasks that has startTime before or at the same time as
     * dateTime
     *
     *            high endpoint (inclusive) of the Tasks in the returned list
     * @return a list of Tasks that starts before or at the same time as
     *         dateTime
     */
    public List<Task> searchByDate(CustomTime start, CustomTime end) {
        // Search for all
        return this.getAll().stream()
                .filter(task -> {
                    // When time is null, we assume it's unbounded
                    boolean startSatisfies = start == null || task.getStartTime().compareTo(start) >= 0;
                    boolean endSatisfies = end == null || task.getEndTime().compareTo(end) <= 0;
                    return startSatisfies && endSatisfies;
                })
                .collect(Collectors.toList());
    }

    public DiskIO getDiskIO() {
        return DiskIO.getInstance();
    }

    // ----------------------------------------------------------------------------------------
    //
    // VI. Read From Disk Method
    //
    // ----------------------------------------------------------------------------------------

    public void readFromDisk() {
        readFromDisk(this.getDiskIO().read());
    }

    public void readFromDisk(List<String> taskStrings) {
        taskStrings.stream()
                .map(Task::decodeTaskFromString)
                .forEach(this::save);

        this._isDirty = false;
    }

    @Override
    public void shutdown() {
        this.writeToDisk();
        this._autosaveTimer.cancel();
    }

}
```
###### ./main/java/storage/TaskPriorityComparator.java
``` java
 *
 */
public class TaskPriorityComparator implements Comparator<Task> {

    private static TaskPriorityComparator instance = new TaskPriorityComparator();

    public static TaskPriorityComparator getInstance() {
        return instance;
    }

    @Override public int compare(Task task1, Task task2) {
        // Completion comparison
        Integer task1Completed = task1.isCompleted() ? 1 : 0;
        Integer task2Completed = task2.isCompleted() ? 1 : 0;
        int completionComparison = task1Completed.compareTo(task2Completed);
        if (completionComparison != 0) {
            return completionComparison;
        }

        // Start time comparison
        if (task1.getStartTime() == null ^ task2.getStartTime() == null) {
            if (task1.getStartTime() == null) return 1;
            if (task2.getStartTime() == null) return -1;
        }

        if (task1.getStartTime() != null && task2.getStartTime() != null) {
            int startTimeComparison = task1.getStartTime().compareTo(task2.getStartTime());
            if (startTimeComparison != 0) return startTimeComparison;
        }

        // Priority comparison
        int priorityComparison = task2.getPriority().compareTo(task1.getPriority());
        if (priorityComparison != 0) return priorityComparison;

        // End time comparison
        if (task1.getEndTime() == null ^ task2.getEndTime() == null) {
            if (task1.getEndTime() == null) return 1;
            if (task2.getEndTime() == null) return -1;
        }

        if (task1.getEndTime() != null && task2.getEndTime() != null) {
            int endTimeComparison = task1.getEndTime().compareTo(task2.getEndTime());
            if (endTimeComparison != 0) return endTimeComparison;
        }

        // Creation time comparison
        return task1.getCreationTime().compareTo(task2.getCreationTime());
    }
}
```
###### ./main/java/storage/UserPreferences.java
``` java
 *
 */
public class UserPreferences {

    private static UserPreferences instance = new UserPreferences();

    public static UserPreferences getInstance() {
        return instance;
    }

    /**
     * Properties
     */
    private String todoDataPath;
    private static final String defaultToDoPath = "data/ToDoData.csv";
    private static final String preferencesFileName = "data/user/UserPreferences.json";

    /**
     * Constructor
     */
    private UserPreferences() {
        createOrReadPreferencesFile();
    }

    /**
     * Reads user preferences file stored on disk and set the To-Do data path as
     * specified in the file. If user preferences file does not already exist,
     * assign the default To-Do data path and create a new user preferences file
     * on disk.
     */

    public void createOrReadPreferencesFile() {
        boolean preferencesFileExists = checkPreferencesFileExists();
        if (!preferencesFileExists) {
            this.setTodoDataPath(this.defaultToDoPath); // set path to default
                                                        // one
            try {
                this.writeUserPreferencesToDisk(); // create preferences file on
                                                   // disk
            } catch (IOException e) {
                ExceptionHandler.handle(e);
            }
        } else {
            try {
                readUserPreferencesFromDisk(); // read existing preferences file
            } catch (IOException e) {
                ExceptionHandler.handle(e);
            }
        }
    }

    /**
     * Checks if json file containing user preferences data already exist,
     * creates a new file if it does not
     *
     * @return true if the file already exists, false otherwise
     */
    public boolean checkPreferencesFileExists() {
        File file = new File(this.preferencesFileName);
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                ExceptionHandler.handle(e);
            }
            return false; // return false if file was newly created
        }
        return true; // return true if file already existed prior to executing
                     // this method
    }

    /**
     * Resets UserPreferences attributes to default values
     */
    public void resetUserPreferences() {
        File file = new File(this.preferencesFileName);
        file.delete();
        this.todoDataPath = this.defaultToDoPath;
    }

    // ----------------------------------------------------------------------------------------
    //
    // I. Gson Serializing Methods
    //
    // ----------------------------------------------------------------------------------------

    public class UserPreferencesSerializer implements JsonSerializer<UserPreferences> {

        @Override public JsonElement serialize(UserPreferences userPreferences, Type typeOfSrc,
                JsonSerializationContext context) {
            JsonObject jsonObject = new JsonObject();
            jsonObject.addProperty("todoDataPath", userPreferences.getTodoDataPath());
            return jsonObject;
        }
    }

    /**
     * Write user preferences data to disk in json format.
     *
     * @throws IOException
     */
    public void writeUserPreferencesToDisk() throws IOException {
        String json = prepareJson();

        File file = new File(this.preferencesFileName);
        this.createDirectory(this.preferencesFileName);
        FileWriter fileWriter = new FileWriter(file);
        fileWriter.write(json);
        fileWriter.close();
    }

    /**
     * Prepare json to be written to disk.
     *
     * @return
     */
    public String prepareJson() {
        // Configure GSON
        GsonBuilder gsonBuilder = new GsonBuilder();
        gsonBuilder.registerTypeAdapter(UserPreferences.class, new UserPreferencesSerializer());
        Gson gson = gsonBuilder.create();

        // Format to JSON
        String json = gson.toJson(this);

        return json;
    }

    public void createDirectory(String fileName) {
        // Try to create directory
        File folder = new File(fileName).getParentFile();
        folder.mkdirs();
    }

    // ----------------------------------------------------------------------------------------
    //
    // II. Gson Deserializing Methods
    //
    // ----------------------------------------------------------------------------------------

    public class UserPreferencesDeserializer implements JsonDeserializer<UserPreferences> {

        @Override public UserPreferences deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
                throws JsonParseException {
            final JsonObject jsonObject = json.getAsJsonObject();
            final JsonElement jsonDataFileName = jsonObject.get("todoDataPath");
            final String toDoDataPath = jsonDataFileName.getAsString();
            UserPreferences userPreferences = UserPreferences.this;
            userPreferences.setTodoDataPath(toDoDataPath);
            return userPreferences;
        }
    }

    /**
     * Read user preferences data from disk in json format.
     *
     * @throws IOException
     */
    public void readUserPreferencesFromDisk() throws IOException {
        this.handleJson(this.readLineFromDisk());
    }

    /**
     * Process json to obtain Java object.
     *
     * @param jsonString
     */
    public void handleJson(String jsonString) {
        // Configure Gson
        GsonBuilder gsonBuilder = new GsonBuilder();
        gsonBuilder.registerTypeAdapter(UserPreferences.class, new UserPreferencesDeserializer());
        Gson gson = gsonBuilder.create();
        UserPreferences userPreferences = gson.fromJson(jsonString, UserPreferences.class);
        this.setTodoDataPath(userPreferences.getTodoDataPath());
    }

    public String readLineFromDisk() {
        String jsonString = null;
        try {
            BufferedReader reader = new BufferedReader(new FileReader(this.preferencesFileName));
            jsonString = reader.readLine();
        } catch (IOException e) {
            ExceptionHandler.handle(e);
        }
        return jsonString;
    }

    // ----------------------------------------------------------------------------------------
    //
    // III. Getter and Setter Methods
    //
    // ----------------------------------------------------------------------------------------

    public String getTodoDataPath() {
        if (ApplicationContext.mainContext().isTestingMode()) {
            return "tmp/ToDoData.csv";
        }
        return this.todoDataPath;
    }

    public void setTodoDataPath(String pathName) {
        this.todoDataPath = pathName;
    }
}
```
###### ./test/java/storage/DiskIOTest.java
``` java
 *
 */
public class DiskIOTest {

    private DiskIO _diskIO;
    private Storage _storage;

    @Before public void setUp() {
        this._storage = Storage.getInstance();
        this._diskIO = DiskIO.getInstance();

        // Clear remnants of previous test(s)
        this._storage.removeAll();
        //this._storage.writeToDisk();
        File file = new File("tmp/ToDoData.csv");
        file.delete();
        this._diskIO.setFileName("tmp/ToDoData.csv");
    }

    @Test public void File_does_not_exist_upon_setting_up() throws IOException {
        File file = new File("tmp/ToDoData.csv");
        assertFalse(file.exists());
    }

    // ----------------------------------------------------------------------------------------
    //
    // I. Read Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Read_function_creates_new_data_file_if_none_exists() {
        File file = new File("tmp/ToDoData.csv");
        file.delete();
        assertFalse(file.exists());
        assertEquals("tmp/ToDoData.csv", this._diskIO.getFileName());
        this._diskIO.read();
        // Check that file gets created after the read method is called
        assertTrue(file.exists());
    }

    @Test public void Read_function_extracts_tasks_data_from_file() {
        String taskString1 = "1,marketing pitch,client FGH,2016-03-01T08:00,2016-03-04T10:00,2016-03-04T12:00,true,2";
        String taskString2 = "2,sales meeting,client IJK,2016-03-02T09:00,2016-03-05T11:30,2016-03-05T13:30,false,2";
        String taskString3 = "3,sales meeting,internal,2016-03-04T07:00,2016-03-06T09:30,2016-03-06T11:30,false,1";

        ArrayList<String> taskStrings = new ArrayList<String>();
        taskStrings.add(taskString1);
        taskStrings.add(taskString2);
        taskStrings.add(taskString3);

        // stub
        // write the data to file as a string
        BufferedWriter writer;
        try {
            writer = new BufferedWriter(new FileWriter("tmp/ToDoData.csv"));
            for (String taskString : taskStrings) {
                writer.write(taskString);
                writer.newLine();
            }
            writer.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            ExceptionHandler.handle(e);
        }
        assertEquals("tmp/ToDoData.csv", this._diskIO.getFileName());
        ArrayList<String> actualTaskList = this._diskIO.read();
        // Check that actual list matches expected list
        assertEquals(taskStrings, actualTaskList);
    }

    // ----------------------------------------------------------------------------------------
    //
    // II. Write Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Write_function_writes_data_into_file_correctly() throws IOException {

        String taskString1 = "1,marketing pitch,client XYZ,2016-03-01T08:00,2016-03-09T14:30,2016-03-09T16:30,false,3";
        String taskString2 = "2,sales meeting,client ABC,2016-03-04T07:00,2016-03-11T12:00,2016-03-11T14:30,true,2";
        ArrayList<String> taskStrings = new ArrayList<String>();
        taskStrings.add(taskString1);
        taskStrings.add(taskString2);

        this._diskIO.write(taskStrings);

        BufferedReader reader = new BufferedReader(new FileReader("tmp/ToDoData.csv"));
        assertEquals("1,marketing pitch,client XYZ,2016-03-01T08:00,2016-03-09T14:30,2016-03-09T16:30,false,3",
                reader.readLine());
        assertEquals("2,sales meeting,client ABC,2016-03-04T07:00,2016-03-11T12:00,2016-03-11T14:30,true,2",
                reader.readLine());
        reader.close();
    }

    // ----------------------------------------------------------------------------------------
    //
    // III. User Preferences Tests
    //
    // ----------------------------------------------------------------------------------------
    @Test public void Loading_user_preferences_from_file_correctly_assigns_custom_file_name() {
        // Write a json file to disk
        File file = new File("data/user/UserPreferences.json");
        file.delete();
        assertFalse(file.exists());
        File folder = new File("data/user/UserPreferences.json").getParentFile();
        folder.mkdirs();
        BufferedWriter bufferedWriter;
        try {
            bufferedWriter = new BufferedWriter(new FileWriter(("data/user/UserPreferences.json")));
            bufferedWriter.write("{\"todoDataPath\":\"/Users/Mary/Dropbox/ToDoData.csv\"}");
            bufferedWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        assertTrue(file.exists());
        this._diskIO.processUserPreferencesFile();
        assertEquals("/Users/Mary/Dropbox/ToDoData.csv", this._diskIO.getFileName());
    }
}
```
###### ./test/java/storage/StorageTest.java
``` java
 *
 */

public class StorageTest {

    private Storage _storage;

    @Before public void setUp() {
        this._storage = Storage.getInstance();

        // Clear all pre-existing data in TaskCollection
        this._storage.removeAll();
    }

    // ----------------------------------------------------------------------------------------
    //
    // I. Save Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Save_returns_correct_Task_ID() {
        int returnedID = this._storage.save(new Task(null, "marketing pitch", "client XYZ",
                new CustomTime(LocalDateTime.of(2016, 3, 9, 14, 30)), new CustomTime(LocalDateTime.of(2016, 3, 9, 16, 30))));
        assertEquals(1, returnedID);
    }

    @Test public void Save_sets_ID_when_ID_is_null() {
        // create Task with null value as ID
        Task taskNullID = new Task(null, "assignment", "cs3230", new CustomTime(LocalDateTime.of(2016, 3, 4, 14, 30)),
                new CustomTime(LocalDateTime.of(2016, 3, 5, 14, 30)));

        // the next assigned ID will be 1
        this._storage.save(taskNullID);
        assertSame(1, this._storage.get(1).getId());
        assertEquals("assignment", this._storage.get(1).getTaskName());
        assertEquals("cs3230", this._storage.get(1).getDescription());
        assertEquals(new CustomTime(LocalDateTime.of(2016, 3, 4, 14, 30)), this._storage.get(1).getStartTime());
        assertEquals(new CustomTime(LocalDateTime.of(2016, 3, 5, 14, 30)), this._storage.get(1).getEndTime());

    }

    @Test public void Write_to_disk_method_works_correctly() {
        File actualFile = new File("tmp/ToDoData.csv");
        this._storage.getDiskIO().setFileName("tmp/ToDoData.csv");

        Task task1 = new Task(null, "marketing pitch", "client XYZ", new CustomTime(LocalDateTime.of(2016, 3, 9, 14, 30)),
                new CustomTime(LocalDateTime.of(2016, 3, 9, 16, 30)));
        Task task2 = new Task(null, "sales meeting", "client ABC", new CustomTime(LocalDateTime.of(2016, 3, 11, 12, 00)),
                new CustomTime(LocalDateTime.of(2016, 3, 11, 14, 30)));
        this._storage.save(task1);
        this._storage.save(task2);
        //this._storage.writeToDisk();

        // check that file gets created when writeToFile() is called
        assertTrue(actualFile.isFile());

        // delete the file for future testing of writing file function
        actualFile.delete();

        // check that file does not exist in the end after deletion
        assertFalse(actualFile.isFile());
    }

    // ----------------------------------------------------------------------------------------
    //
    // II. Get Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Get_returns_correct_Task() {
        Task task3 = new Task(null, "sales training", "HR", new CustomTime(LocalDateTime.of(2016, 3, 10, 14, 30)),
                new CustomTime(LocalDateTime.of(2016, 3, 10, 16, 30)));
        Task task4 = new Task(null, "meeting to discuss proposal", "sales team", new CustomTime(LocalDateTime.of(2016, 3, 11, 12, 00)),
                new CustomTime(LocalDateTime.of(2016, 3, 11, 14, 30)));
        this._storage.save(task3);
        this._storage.save(task4);
        task3.setId(1);
        task4.setId(2);

        assertEquals(task3, this._storage.get(1));
        assertEquals(task4, this._storage.get(2));

    }

    // ----------------------------------------------------------------------------------------
    //
    // III. GetAll Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Get_all_method_returns_list_correctly() {
        Task task5 = new Task(null, "tutorial", "nm2101", new CustomTime(LocalDateTime.of(2016, 3, 7, 14, 30)),
                new CustomTime(LocalDateTime.of(2016, 3, 8, 14, 30)));
        Task task6 = new Task(null, "essay submission", "nm3238", new CustomTime(LocalDateTime.of(2016, 3, 8, 12, 00)),
                new CustomTime(LocalDateTime.of(2016, 3, 9, 15, 30)));
        this._storage.save(task5);
        this._storage.save(task6);
        task5.setId(1);
        task6.setId(2);

        ArrayList<Task> expectedTaskList = new ArrayList<>();
        expectedTaskList.add(task5);
        expectedTaskList.add(task6);
        // assert that expected and actual ArrayLists are equal
        assertEquals(expectedTaskList, this._storage.getAll());
    }

    // ----------------------------------------------------------------------------------------
    //
    // IV. Remove Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Remove_deletes_correct_Task() {
        Task task7 = new Task(null, "minor project", "cs1020", new CustomTime(LocalDateTime.of(2016, 3, 7, 14, 30)),
                new CustomTime(LocalDateTime.of(2016, 3, 8, 14, 30)));
        Task task8 = new Task(null, "major project", "cs2102", new CustomTime(LocalDateTime.of(2016, 3, 8, 12, 00)),
                new CustomTime(LocalDateTime.of(2016, 3, 9, 15, 30)));
        this._storage.save(task7);
        this._storage.save(task8);

        // check that task7 was deleted
        Task deletedTask = this._storage.remove(1);
        assertEquals(task7, deletedTask);
        // check that isDeleted flag has been change to true
        assertEquals(true, deletedTask.isDeleted());

        // check that get() returns null
        assertNull(this._storage.get(1));
        assertNotNull(this._storage.get(2));

        // check that getAll() does not return the deleted Task, but keeps the
        // undeleted Task
        ArrayList<Task> taskList = new ArrayList<Task>(this._storage.getAll());
        assertFalse(taskList.contains(task7));
        assertTrue(taskList.contains(task8));
    }

    @Test public void Removing_invalid_index_returns_null_value() {
        Task task7 = new Task(null, "minor project", "cs1020", new CustomTime(LocalDateTime.of(2016, 3, 7, 14, 30)),
                new CustomTime(LocalDateTime.of(2016, 3, 8, 14, 30)));
        Task task8 = new Task(null, "major project", "cs2102", new CustomTime(LocalDateTime.of(2016, 3, 8, 12, 00)),
                new CustomTime(LocalDateTime.of(2016, 3, 9, 15, 30)));
        this._storage.save(task7);
        this._storage.save(task8);

        assertNull(this._storage.remove(3));
    }

    @Test public void Remove_all_clears_all_data() {
        Task task9 = new Task(null, "assignment 3", "cs3223", new CustomTime(LocalDateTime.of(2016, 3, 10, 14, 30)),
                new CustomTime(LocalDateTime.of(2016, 3, 12, 12, 00)));
        Task task10 = new Task(null, "homework", "ma1101r", new CustomTime(LocalDateTime.of(2016, 3, 8, 12, 00)),
                new CustomTime(LocalDateTime.of(2016, 3, 10, 15, 30)));
        this._storage.save(task9);
        this._storage.save(task10);

        this._storage.removeAll();
    }

    // ----------------------------------------------------------------------------------------
    //
    // V. Search by Time Range Tests
    //
    // ----------------------------------------------------------------------------------------

    public ArrayList<Task> Set_up_for_search_by_time_range_tests() {
        ArrayList<Task> taskList = new ArrayList<Task>();

        String TASK_1_NAME = "homework";
        String TASK_1_DESCRIPTION = "cs2103t";
        LocalDateTime TASK_1_START = LocalDateTime.of(2016, 3, 4, 10, 00);
        LocalDateTime TASK_1_END = LocalDateTime.of(2016, 3, 5, 12, 30);
        Task TASK_1 = new Task(null, TASK_1_NAME, TASK_1_DESCRIPTION, TASK_1_START, TASK_1_END);
        this._storage.save(TASK_1);
        TASK_1.setId(1);
        taskList.add(TASK_1);

        String TASK_2_NAME = "assignment";
        String TASK_2_DESCRIPTION = "cs3230";
        LocalDateTime TASK_2_START = LocalDateTime.of(2016, 3, 5, 13, 30);
        LocalDateTime TASK_2_END = LocalDateTime.of(2016, 3, 6, 13, 30);
        Task TASK_2 = new Task(null, TASK_2_NAME, TASK_2_DESCRIPTION, TASK_2_START, TASK_2_END);
        this._storage.save(TASK_2);
        TASK_2.setId(2);
        taskList.add(TASK_2);

        String TASK_3_NAME = "essay submission";
        String TASK_3_DESCRIPTION = "nm2101";
        LocalDateTime TASK_3_START = LocalDateTime.of(2016, 3, 6, 14, 30);
        LocalDateTime TASK_3_END = LocalDateTime.of(2016, 3, 7, 14, 30);
        Task TASK_3 = new Task(null, TASK_3_NAME, TASK_3_DESCRIPTION, TASK_3_START, TASK_3_END);
        this._storage.save(TASK_3);
        TASK_3.setId(3);
        taskList.add(TASK_3);

        String TASK_4_NAME = "tutorial";
        String TASK_4_DESCRIPTION = "nm2213";
        LocalDateTime TASK_4_START = LocalDateTime.of(2016, 3, 7, 15, 30);
        LocalDateTime TASK_4_END = LocalDateTime.of(2016, 3, 8, 16, 30);
        Task TASK_4 = new Task(null, TASK_4_NAME, TASK_4_DESCRIPTION, TASK_4_START, TASK_4_END);
        this._storage.save(TASK_4);
        TASK_4.setId(4);
        taskList.add(TASK_4);

        String TASK_5_NAME = "project report";
        String TASK_5_DESCRIPTION = "cs2102";
        LocalDateTime TASK_5_START = LocalDateTime.of(2016, 3, 8, 17, 30);
        LocalDateTime TASK_5_END = LocalDateTime.of(2016, 3, 9, 19, 30);
        Task TASK_5 = new Task(null, TASK_5_NAME, TASK_5_DESCRIPTION, TASK_5_START, TASK_5_END);
        this._storage.save(TASK_5);
        TASK_5.setId(5);
        taskList.add(TASK_5);

        return taskList;
    }

    @Test public void Searching_by_start_before_returns_list_correctly() {
        ArrayList<Task> fullTaskList = Set_up_for_search_by_time_range_tests();
        ArrayList<Task> expectedTaskList = new ArrayList<Task>(fullTaskList.subList(0, 3));

        // assert that expected results and actual search results are the same
//        assertEquals(expectedTaskList, this._storage.searchstartBefore(LocalDateTime.of(2016, 3, 6, 14, 30)));
    }

    @Test public void Searching_by_start_after_returns_list_correctly() {
        ArrayList<Task> fullTaskList = Set_up_for_search_by_time_range_tests();
        ArrayList<Task> expectedTaskList = new ArrayList<Task>(fullTaskList.subList(2, 5));

        // assert that expected results and actual search results are the same
//        assertEquals(expectedTaskList, this._storage.searchStartAfter(LocalDateTime.of(2016, 3, 6, 14, 30)));
    }

    @Test public void Searching_by_end_before_returns_list_correctly() {
        ArrayList<Task> fullTaskList = Set_up_for_search_by_time_range_tests();
        ArrayList<Task> expectedTaskList = new ArrayList<Task>(fullTaskList.subList(0, 3));

        // assert that expected results and actual search results are the same
//        assertEquals(expectedTaskList, this._storage.searchEndBefore(LocalDateTime.of(2016, 3, 7, 14, 30)));
    }

    @Test public void Searching_by_end_after_returns_list_correctly() {
        ArrayList<Task> fullTaskList = Set_up_for_search_by_time_range_tests();
        ArrayList<Task> expectedTaskList = new ArrayList<Task>(fullTaskList.subList(2, 5));

        // assert that expected results and actual search results are the same
//        assertEquals(expectedTaskList, this._storage.searchEndAfter(LocalDateTime.of(2016, 3, 7, 14, 30)));
    }

    @Test public void Searching_by_date_time_range_returns_list_correctly() {
        ArrayList<Task> fullTaskList = Set_up_for_search_by_time_range_tests();
        ArrayList<Task> expectedTaskList = new ArrayList<Task>(fullTaskList.subList(1, 4));

        // assert that expected results and actual search results are the same
//        assertEquals(expectedTaskList, this._storage.searchByDateTimeRange(LocalDateTime.of(2016, 3, 5, 13, 30),
//                LocalDateTime.of(2016, 3, 8, 16, 30)));
    }

    // ----------------------------------------------------------------------------------------
    //
    // VI. Updating Start and End Time Trees Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Task_entry_in_tree_gets_shifted_when_start_time_changes() {
        ArrayList<Task> fullTaskList = Set_up_for_search_by_time_range_tests();
        Task task1 = fullTaskList.get(0);

        // check that the list initially contains the old task
//        assertTrue(this._storage.getStartTimeTree().get(LocalDateTime.of(2016, 3, 4, 10, 00)).contains(task1));

        Task editedTask1 = new Task(1, "homework", "cs2103t", LocalDateTime.of(2016, 3, 5, 00, 00),
                LocalDateTime.of(2016, 3, 5, 12, 30));
        // edit the start time of task1
        this._storage.save(editedTask1);

        // check that the list corresponding to the old start time no longer
        // contains the task
//        assertFalse(this._storage.getStartTimeTree().get(LocalDateTime.of(2016, 3, 4, 10, 00)).contains(task1));

        // check that the list corresponding to the new start time now contains
        // the updated task
//        assertTrue(this._storage.getStartTimeTree().get(LocalDateTime.of(2016, 3, 5, 00, 00)).contains(editedTask1));
    }

    @Test public void Task_entry_in_tree_gets_shifted_when_end_time_changes() {
        ArrayList<Task> fullTaskList = Set_up_for_search_by_time_range_tests();
        Task task2 = fullTaskList.get(1);

        // check that the list initially contains the old task
//        assertTrue(this._storage.getEndTimeTree().get(LocalDateTime.of(2016, 3, 6, 13, 30)).contains(task2));

        Task editedTask2 = new Task(2, "assignment", "cs3230", LocalDateTime.of(2016, 3, 5, 13, 30),
                LocalDateTime.of(2016, 3, 6, 00, 30));
        // edit the end time of task2
        this._storage.save(editedTask2);

        // check that the list corresponding to the old end time no longer
        // contains the task
//        assertFalse(this._storage.getEndTimeTree().get(LocalDateTime.of(2016, 3, 6, 13, 30)).contains(task2));

        // check that the list corresponding to the new end time now contains
        // the updated task
//        assertTrue(this._storage.getEndTimeTree().get(LocalDateTime.of(2016, 3, 6, 00, 30)).contains(editedTask2));
    }

    // ----------------------------------------------------------------------------------------
    //
    // VII. Read From Disk Method Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Read_from_disk_method_works_correctly() {
        String taskString1 = "1,marketing pitch,client XYZ,2016-03-01T00:01,2016-03-09T14:30,2016-03-09T16:30,true,3";
        String taskString2 = "2,sales meeting,client ABC,2016-03-03T12:05,2016-03-11T12:00,2016-03-11T14:30,false,1";
        ArrayList<String> taskStrings = new ArrayList<String>();
        taskStrings.add(taskString1);
        taskStrings.add(taskString2);

        this._storage.removeAll();
        this._storage.readFromDisk(taskStrings);
        assertEquals((Integer) 1, this._storage.get(1).getId());
        assertEquals("marketing pitch", this._storage.get(1).getTaskName());
        assertEquals(LocalDateTime.parse("2016-03-01T00:01"), this._storage.get(1).getCreationTime());
        assertEquals(CustomTime.fromString("2016-03-09T14:30"), this._storage.get(1).getStartTime());
        assertEquals(CustomTime.fromString("2016-03-09T16:30"), this._storage.get(1).getEndTime());
        assertTrue(this._storage.get(1).isCompleted());
        assertEquals(Task.Priority.HIGH, this._storage.get(1).getPriority());
        assertEquals((Integer) 2, this._storage.get(2).getId());
        assertEquals("sales meeting", this._storage.get(2).getTaskName());
        assertEquals(LocalDateTime.parse("2016-03-03T12:05"), this._storage.get(2).getCreationTime());
        assertEquals(CustomTime.fromString("2016-03-11T12:00"), this._storage.get(2).getStartTime());
        assertEquals(CustomTime.fromString("2016-03-11T14:30"), this._storage.get(2).getEndTime());
        assertFalse(this._storage.get(2).isCompleted());
        assertEquals(Task.Priority.NULL, this._storage.get(2).getPriority());
    }

}
```
###### ./test/java/storage/TaskPriorityComparatorTest.java
``` java
 *
 */
public class TaskPriorityComparatorTest {

    private Storage storage_;

    @Before public void Set_up() {
        this.storage_ = Storage.getInstance();
        this.storage_.removeAll();
    }

    @Test public void Tasks_with_different_priorities_are_ordered_correctly() {
        CustomTime standardStartTime = new CustomTime(LocalDateTime.of(2016, 3, 2, 11, 59));
        CustomTime standardEndTime = new CustomTime(LocalDateTime.of(2016, 4, 20, 18, 00));

        Task highPriorityTask = new Task(null, "report submission", null, standardStartTime, standardEndTime);
        highPriorityTask.setPriority(Priority.HIGH);
        Task mediumPriorityTask = new Task(null, "sales team meeting", null, standardStartTime, standardEndTime);
        mediumPriorityTask.setPriority(Priority.MEDIUM);
        Task lowPriorityTask = new Task(null, "submit v0.1", null, standardStartTime, standardEndTime);
        lowPriorityTask.setPriority(Priority.LOW);

        this.storage_.save(mediumPriorityTask); // mediumPriorityTask ID: 1
        this.storage_.save(lowPriorityTask); // lowPriorityTask ID: 2
        this.storage_.save(highPriorityTask); // highPriorityTask ID: 3
        List<Task> taskList = this.storage_.getAll();

        // sort
        Collections.sort(taskList, new TaskPriorityComparator());

        // check that high priority task comes before low priority task
        assertEquals(highPriorityTask, taskList.get(0));
        assertEquals(mediumPriorityTask, taskList.get(1));
        assertEquals(lowPriorityTask, taskList.get(2));
    }

    @Test public void Mix_of_tasks_with_priority_values_and_null_priorities_are_ordered_correctly() {
        CustomTime standardStartTime = new CustomTime(LocalDateTime.of(2016, 3, 30, 10, 00));
        CustomTime standardEndTime = new CustomTime(LocalDateTime.of(2016, 4, 1, 14, 30));

        // default priority is null
        Task nullPriorityTask = new Task(null, "draft progress report", null, standardStartTime, standardEndTime);
        Task lowPriorityTask = new Task(null, "make software demo slides", null, standardStartTime, standardEndTime);
        lowPriorityTask.setPriority(Priority.LOW);
        Task highPriorityTask = new Task(null, "v0.4 milestone delivery", null, standardStartTime, standardEndTime);
        highPriorityTask.setPriority(Priority.HIGH);

        this.storage_.save(nullPriorityTask); // nullPriorityTask ID: 1
        this.storage_.save(lowPriorityTask); // lowPriorityTask ID: 2
        this.storage_.save(highPriorityTask); // highPriorityTask ID: 3
        List<Task> taskList = this.storage_.getAll();

        // sort
        Collections.sort(taskList, new TaskPriorityComparator());

        // check that low priority task comes last, right below null priority task
        assertEquals(highPriorityTask, taskList.get(0));
        assertEquals(nullPriorityTask, taskList.get(1));
        assertEquals(lowPriorityTask, taskList.get(2));
    }

    @Test public void Tasks_with_same_priorities_but_different_start_times_are_ordered_correctly() {
        CustomTime standardEndTime = new CustomTime(LocalDateTime.of(2016, 4, 20, 18, 00));

        Task earlyStartTask = new Task(null, "proposal v0.1", null, new CustomTime(LocalDateTime.of(2016, 4, 1, 12, 00)), standardEndTime);
        Task middleStartTask = new Task(null, "project manual", null, new CustomTime(LocalDateTime.of(2016, 4, 2, 15, 30)), standardEndTime);
        Task lateStartTask = new Task(null, "oral presentation", null, new CustomTime(LocalDateTime.of(2016, 4, 3, 11, 00)), standardEndTime);
        this.storage_.save(lateStartTask); // lateStartTask ID: 1
        this.storage_.save(earlyStartTask); // earlyStartTask ID: 2
        this.storage_.save(middleStartTask); // middleStartTask ID: 3
        List<Task> taskList = this.storage_.getAll();

        // sort
        Collections.sort(taskList, new TaskPriorityComparator());

        // check that task with earlier start time comes before task with later start time
        assertEquals(earlyStartTask, taskList.get(0)); // earlyStartTask
        assertEquals(middleStartTask, taskList.get(1)); // middleStartTask
        assertEquals(lateStartTask, taskList.get(2)); // lateStartTask
    }

    @Test public void Tasks_are_ordered_correctly_when_start_time_is_null() {
        CustomTime standardEndTime = new CustomTime(LocalDateTime.of(2016, 3, 21, 23, 00));

        Task earlyStartTask = new Task(null, "v0.1 demo", null, new CustomTime(LocalDateTime.of(2016, 3, 1, 13, 00)), standardEndTime);
        Task lateStartTask = new Task(null, "v0.2 demo", null, new CustomTime(LocalDateTime.of(2016, 3, 7, 12, 30)), standardEndTime);
        Task nullStartTask = new Task(null, "future developments of Your MOM", null, null, standardEndTime);
        this.storage_.save(lateStartTask); // lateStartTask ID: 1
        this.storage_.save(nullStartTask); // nullStartTask ID: 2
        this.storage_.save(earlyStartTask); // earlyStartTask ID: 3
        List<Task> taskList = this.storage_.getAll();

        // sort
        Collections.sort(taskList, new TaskPriorityComparator());

        // check that task with early start time comes first, task with null start time comes last
        assertEquals(earlyStartTask, taskList.get(0));
        assertEquals(lateStartTask, taskList.get(1));
        assertEquals(nullStartTask, taskList.get(2));
    }

    @Test public void Tasks_with_same_priorities_and_start_times_but_different_end_times_are_ordered_correctly() {
        CustomTime standardStartTime = new CustomTime(LocalDateTime.of(2016, 3, 2, 11, 59));

        Task earlyEndTask = new Task(null, "reflection 1", null, standardStartTime, new CustomTime(LocalDateTime.of(2016, 3, 7, 17, 00)));
        Task middleEndTask = new Task(null, "progress report", null, standardStartTime, new CustomTime(LocalDateTime.of(2016, 3, 14, 20, 00)));
        Task lateEndTask = new Task(null, "reflection 2", null, standardStartTime, new CustomTime(LocalDateTime.of(2016, 3, 21, 23, 59)));
        this.storage_.save(middleEndTask); // middleEndTask ID: 1
        this.storage_.save(lateEndTask); // lateEndTask ID: 2
        this.storage_.save(earlyEndTask); // earlyEndTask ID: 3
        List<Task> taskList = this.storage_.getAll();

        // sort
        Collections.sort(taskList, new TaskPriorityComparator());

        // check that task with earlier end time comes before task with later end time
        assertEquals(earlyEndTask, taskList.get(0)); // earlyEndTask
    }

    @Test public void Tasks_are_ordered_correctly_when_end_time_is_null() {
        CustomTime standardStartTime = new CustomTime(LocalDateTime.of(2016, 3, 9, 23, 59));

        Task earlyEndTask = new Task(null, "v0.1 demo", null, standardStartTime, new CustomTime(LocalDateTime.of(2016, 3, 20, 12, 00)));
        Task lateEndTask = new Task(null, "v0.2 demo", null, standardStartTime, new CustomTime(LocalDateTime.of(2016, 4, 1, 23, 59)));
        Task nullEndTask = new Task(null, "future developments of Your MOM", null, standardStartTime, null);
        this.storage_.save(nullEndTask); // nullEndTask ID: 1
        this.storage_.save(earlyEndTask); // earlyEndTask ID: 2
        this.storage_.save(lateEndTask); // lateEndTask ID: 3
        List<Task> taskList = this.storage_.getAll();

        // sort
        Collections.sort(taskList, new TaskPriorityComparator());

        // check that task with early start time comes first, task with null start time comes last
        assertEquals(earlyEndTask, taskList.get(0));
        assertEquals(lateEndTask, taskList.get(1));
        assertEquals(nullEndTask, taskList.get(2));
    }

    @Test public void Tasks_with_same_priorities_and_start_times_and_same_end_times_but_different_creation_times_are_ordered_correctly() {
        CustomTime standardStartTime = new CustomTime(LocalDateTime.of(2016, 3, 9, 12, 30));
        CustomTime standardEndTime = new CustomTime(LocalDateTime.of(2016, 3, 9, 13, 00));

        try {
            Task earlierCreationTask = new Task(null, "submit progress report", null,
                    standardStartTime, standardEndTime);
            Thread.sleep(3000); // sleep for 3 seconds
            Task middleCreationTask = new Task(null, "marketing pitch", null,
                    standardStartTime, standardEndTime);
            Thread.sleep(3000); // sleep for 3 seconds
            Task laterCreationTask = new Task(null, "sales meeting", null,
                    standardStartTime, standardEndTime);

            this.storage_.save(middleCreationTask);
            this.storage_.save(laterCreationTask);
            this.storage_.save(earlierCreationTask);
            List<Task> taskList = this.storage_.getAll();

            // sort
            Collections.sort(taskList, new TaskPriorityComparator());

            // check that task with the earliest creation time comes first
            assertEquals(earlierCreationTask, taskList.get(0));
            assertEquals(middleCreationTask, taskList.get(1));
            assertEquals(laterCreationTask, taskList.get(2));

        } catch (InterruptedException e) {
            ExceptionHandler.handle(e);
        }

    }

}
```
###### ./test/java/storage/TaskTest.java
``` java
 *
 */

public class TaskTest {

    // ----------------------------------------------------------------------------------------
    //
    // I. Encoding To String Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Task_is_encoded_correctly() {
        CustomTime start = new CustomTime(LocalDateTime.of(2016, 3, 6, 14, 30));
        CustomTime end = new CustomTime(LocalDateTime.of(2016, 3, 8, 14, 30));
        Task task1 = new Task(1, "proposal", "client ABC", start, end);
        task1.setCompleted(true);
        task1.setPriority(Task.Priority.MEDIUM);
        String taskString = task1.encodeTaskToString();
        String[] taskStringArr = taskString.split(",");
        assertEquals(8, taskStringArr.length);
        assertEquals("1", taskStringArr[0]);
        assertEquals("proposal", taskStringArr[1]);
        assertEquals("client ABC", taskStringArr[2]);
        assertEquals(task1.getCreationTime().toString(), taskStringArr[3]);
        assertEquals(start.toString(), taskStringArr[4]);
        assertEquals(end.toString(), taskStringArr[5]);
        assertEquals("true", taskStringArr[6]); // isCompleted has been set as true
        assertEquals("2", taskStringArr[7]); // task priority medium has a value of 2
    }

    @Test public void Task_with_special_characters_still_encode_correctly() {
        CustomTime start = new CustomTime(LocalDateTime.of(2016, 3, 9, 23, 59));
        CustomTime end = new CustomTime(LocalDateTime.of(2016, 3, 11, 12, 00));
        String specialTaskName = "A task with comma, and \"quotes\", and \"comma, within quotes\"";
        specialTaskName += ", and backslash before quote\\\"";
        Task specialTask = new Task(123, specialTaskName, "Random description", start, end); // priority is set to default
        String creationTime = specialTask.getCreationTime().toString(); // get creationTime to add to expected String for checking
        String specialTaskString = specialTask.encodeTaskToString();

        String expected = "123,"
                + "\"A task with comma, and \\\"quotes\\\", and \\\"comma, within quotes\\\", and backslash before quote\\\\\\\"\",Random description," + creationTime + "," + start.toString() + "," + end.toString() + ",false,1";

        assertEquals(expected, specialTaskString);
    }

    // ----------------------------------------------------------------------------------------
    //
    // II. Decoding From String Tests
    //
    // ----------------------------------------------------------------------------------------

    @Test public void Task_with_special_characters_still_decode_correctly() {
        String specialString = "A task with comma, and \"quotes\", and \"comma, within quotes\", and backslash before quote\\\"";

        // Convert all backslashes to double backslashes
        // Convert all quotes to backslash quote
        // Convert all commas to backslash comma
        String encodedSpecialString = "A task with comma, and \\\"quotes\\\", and \\\"comma, within quotes\\\", and backslash before quote\\\\\\\"";

        CustomTime start = new CustomTime(LocalDateTime.of(2016, 3, 10, 12, 00));
        CustomTime end = new CustomTime(LocalDateTime.of(2016, 3, 11, 22, 30));

        String taskString = "123,\"" + encodedSpecialString + "\",Random description,"
                + LocalDateTime.of(2016, 3, 1, 23, 59).toString() + ","
                + start.toString() + ","
                + end.toString() + ",false,2";

        // decode the task string and check if the task attributes are equal to
        // what we expect
        Task task3 = Task.decodeTaskFromString(taskString);

        assertSame(123, task3.getId());
        assertEquals(specialString, task3.getTaskName());
        assertEquals("Random description", task3.getDescription());
        assertEquals(LocalDateTime.of(2016, 3, 1, 23, 59), task3.getCreationTime());
        assertEquals(start, task3.getStartTime());
        assertEquals(end, task3.getEndTime());
        assertFalse(task3.isCompleted());
        assertEquals(Task.Priority.MEDIUM, task3.getPriority());
    }

    @Test public void Decoded_Task_has_correct_attributes_assigned() {
        String taskString = "88,marketing pitch,to microsoft,2016-03-02T23:59:01,2016-03-09T14:30,2016-03-09T15:30,true,2";
        Task task4 = Task.decodeTaskFromString(taskString);

        assertSame(88, task4.getId());
        assertEquals("marketing pitch", task4.getTaskName());
        assertEquals("to microsoft", task4.getDescription());
        assertEquals(LocalDateTime.parse("2016-03-02T23:59:01"), task4.getCreationTime());
        assertEquals(CustomTime.fromString("2016-03-09T14:30"), task4.getStartTime());
        assertEquals(CustomTime.fromString("2016-03-09T15:30"), task4.getEndTime());
        assertTrue(task4.isCompleted());
        assertEquals(Task.Priority.MEDIUM, task4.getPriority());
    }

    // ----------------------------------------------------------------------------------------
    //
    // III. Set ID Test
    //
    // ----------------------------------------------------------------------------------------

    @Test public void SetId_method_successfully_assign_ID_to_Task() {
        // create Task with null ID
        Task task5 = new Task(null, "proposal", "client XYZ", new CustomTime(LocalDateTime.of(2016, 3, 1, 23, 59)),
                new CustomTime(LocalDateTime.of(2016, 3, 2, 1, 00)));

        // assign an integer ID
        task5.setId(5);

        assertNotNull(task5.getId()); // check that ID is no longer null
        assertSame(5, task5.getId()); // check that ID equals the new assigned
                                      // value

    }

}
```
###### ./test/java/storage/UserPreferencesTest.java
``` java
 *
 */
public class UserPreferencesTest {

    @Test
    public void Default_data_file_name_is_assigned() {
        UserPreferences up = UserPreferences.getInstance();
        up.resetUserPreferences(); // reset to default values
        assertEquals("data/ToDoData.csv", up.getTodoDataPath());
        up.resetUserPreferences();
    }

    @Test
    public void Changes_to_file_name_are_saved_under_user_preferences() {
        UserPreferences up = UserPreferences.getInstance();
        up.resetUserPreferences(); // reset to default values
        up.setTodoDataPath("/Users/Jim/Dropbox/ToDoData.csv");
        assertEquals("/Users/Jim/Dropbox/ToDoData.csv", up.getTodoDataPath());
        up.resetUserPreferences();
    }

    @Test
    public void Serialization_works_correctly() {
        UserPreferences up = UserPreferences.getInstance();
        up.resetUserPreferences();
        up.setTodoDataPath("/Family/Mum/Documents/ToDoData.csv");
        assertEquals("{\"todoDataPath\":\"/Family/Mum/Documents/ToDoData.csv\"}", up.prepareJson());
        up.resetUserPreferences();
    }

    @Test
    public void Writing_to_json_file_works_correctly() {
        UserPreferences up = UserPreferences.getInstance();
        up.resetUserPreferences();
        up.setTodoDataPath("/Public/Guest/Downloads/ToDoData.csv");
        try {
            up.writeUserPreferencesToDisk();
        } catch (IOException e) {
            ExceptionHandler.handle(e);
        }
        File file = new File("data/user/UserPreferences.json");
        String read = "";
        BufferedReader bufferedReader;
        try {
            bufferedReader = new BufferedReader(new FileReader(file));
            read = bufferedReader.readLine();
        } catch (FileNotFoundException e) {
            ExceptionHandler.handle(e);
        } catch (IOException e) {
            ExceptionHandler.handle(e);
        }
        assertEquals("{\"todoDataPath\":\"/Public/Guest/Downloads/ToDoData.csv\"}", read);
        file.delete(); // delete file so that future tests will not be affected
        up.resetUserPreferences();
    }

    @Test
    public void Deserialization_works_correctly() {
        UserPreferences up = UserPreferences.getInstance();
        up.resetUserPreferences();
        String toDeserialize = "{\"todoDataPath\":\"/Users/Jane/GoogleDrive/ToDoData.csv\"}";
        up.handleJson(toDeserialize);
        assertEquals("/Users/Jane/GoogleDrive/ToDoData.csv", up.getTodoDataPath());
        up.resetUserPreferences();
    }

    @Test
    public void Reading_from_existing_user_preferences_data_file_on_disk_works_correctly() {
        // Write a json file to disk
        File file = new File("data/user/UserPreferences.json");
        file.delete();
        assertFalse(file.exists());
        File folder = new File("data/user/UserPreferences.json").getParentFile();
        folder.mkdirs();
        BufferedWriter bufferedWriter;
        try {
            bufferedWriter = new BufferedWriter(new FileWriter(("data/user/UserPreferences.json")));
            bufferedWriter.write("{\"todoDataPath\":\"/Home/XiaoMing/Dropbox/ToDoData.csv\"}");
            bufferedWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        assertTrue(file.exists());

        UserPreferences up = UserPreferences.getInstance();
        up.createOrReadPreferencesFile();
        assertEquals("/Home/XiaoMing/Dropbox/ToDoData.csv", up.getTodoDataPath());

        file.delete();
        up.resetUserPreferences();
    }
}
```
